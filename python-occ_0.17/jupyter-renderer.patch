From 9642f2a667f01e3dc293e7363aeb06effc044b92 Mon Sep 17 00:00:00 2001
From: Martin Siggel <martin.siggel@dlr.de>
Date: Thu, 4 Apr 2019 01:47:17 +0200
Subject: [PATCH] Improved jupyter renderer

---
 CMakeLists.txt                        |   1 +
 src/Display/OCCViewer.py              | 349 +++++++++++----
 src/Display/WebGl/jupyter_renderer.py | 618 ++++++++++++++++++++++++++
 src/Extend/DataExchange.py            | 461 +++++++++++++++++++
 src/Extend/ShapeFactory.py            | 239 ++++++++++
 src/Extend/TopologyUtils.py           | 546 +++++++++++++++++++++++
 src/Extend/__init__.py                |   0
 src/Visualization/Display3d.cpp       | 167 ++++++-
 src/Visualization/Tesselator.cpp      |  96 +++-
 src/Visualization/Tesselator.h        |   8 +-
 src/Visualization/Visualization.h     |  42 +-
 src/Visualization/Visualization.i     | 112 +++--
 12 files changed, 2488 insertions(+), 151 deletions(-)
 create mode 100644 src/Display/WebGl/jupyter_renderer.py
 create mode 100644 src/Extend/DataExchange.py
 create mode 100644 src/Extend/ShapeFactory.py
 create mode 100644 src/Extend/TopologyUtils.py
 create mode 100644 src/Extend/__init__.py

diff --git CMakeLists.txt CMakeLists.txt
index a442dc7..164aa54 100644
--- CMakeLists.txt
+++ CMakeLists.txt
@@ -351,6 +351,7 @@ endif(PYTHONOCC_WRAP_VISU)
 install(FILES ${BUILD_DIR}/Addons.py DESTINATION ${PYTHONOCC_INSTALL_DIRECTORY} )
 install(TARGETS _Addons DESTINATION ${PYTHONOCC_INSTALL_DIRECTORY} )
 install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/src/Display DESTINATION ${PYTHONOCC_INSTALL_DIRECTORY} )
+install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/src/Extend DESTINATION ${PYTHONOCC_INSTALL_DIRECTORY} )
 # install LICENSE file
 install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/LICENSE DESTINATION ${PYTHONOCC_INSTALL_DIRECTORY} )
 # install AUTHORS file
diff --git src/Display/OCCViewer.py src/Display/OCCViewer.py
index 25d2411..a4b8b7b 100644
--- src/Display/OCCViewer.py
+++ src/Display/OCCViewer.py
@@ -1,6 +1,6 @@
 #!/usr/bin/env python
 
-##Copyright 2008-2014 Thomas Paviot (tpaviot@gmail.com)
+##Copyright 2008-2017 Thomas Paviot (tpaviot@gmail.com)
 ##
 ##This file is part of pythonOCC.
 ##
@@ -20,45 +20,69 @@
 from __future__ import print_function
 
 import os
+import os.path
+import time
 import sys
 import math
 import itertools
 
-from OCC.AIS import AIS_MultipleConnectedInteractive, AIS_Shape
+import OCC
+from OCC.Aspect import Aspect_GFM_VER
+from OCC.AIS import AIS_Shape, AIS_Shaded, AIS_TexturedShape, AIS_WireFrame
 from OCC.TopoDS import TopoDS_Shape
 from OCC.gp import gp_Dir, gp_Pnt, gp_Pnt2d, gp_Vec
 from OCC.BRepBuilderAPI import (BRepBuilderAPI_MakeVertex,
-                                BRepBuilderAPI_MakeEdge,
-                                BRepBuilderAPI_MakeEdge2d,
-                                BRepBuilderAPI_MakeFace)
+                                     BRepBuilderAPI_MakeEdge,
+                                     BRepBuilderAPI_MakeEdge2d,
+                                     BRepBuilderAPI_MakeFace)
 from OCC.TopAbs import (TopAbs_FACE, TopAbs_EDGE, TopAbs_VERTEX,
-                        TopAbs_SHELL, TopAbs_SOLID)
-from OCC.Geom import Handle_Geom_Curve, Handle_Geom_Surface
-from OCC.Geom2d import Handle_Geom2d_Curve
-import OCC.Visualization
-import OCC.V3d
-import OCC.AIS
+                             TopAbs_SHELL, TopAbs_SOLID)
+from OCC.Geom import Geom_Curve, Geom_Surface, Handle_Geom_Curve, Handle_Geom_Surface
+from OCC.Geom2d import Geom2d_Curve, Handle_Geom2d_Curve
+from OCC.Visualization import Display3d
+from OCC.V3d import (V3d_ZBUFFER, V3d_PHONG, V3d_Zpos, V3d_Zneg, V3d_Xpos,
+                          V3d_Xneg, V3d_Ypos, V3d_Yneg, V3d_XposYnegZpos, V3d_TEX_ALL,
+                          V3d_TEX_NONE, V3d_TEX_ENVIRONMENT,
+                          V3d_LayerMgr)
 from OCC.TCollection import TCollection_ExtendedString, TCollection_AsciiString
 from OCC.Quantity import (Quantity_Color, Quantity_TOC_RGB, Quantity_NOC_WHITE,
-                          Quantity_NOC_BLACK, Quantity_NOC_BLUE1,
-                          Quantity_NOC_CYAN1, Quantity_NOC_RED,
-                          Quantity_NOC_GREEN,
-                          Quantity_NOC_ORANGE, Quantity_NOC_YELLOW)
-from OCC.Prs3d import (Prs3d_Arrow, Prs3d_Presentation, Prs3d_Text,
-                       Prs3d_TextAspect)
-from OCC.Graphic3d import Graphic3d_NOM_NEON_GNC
-from OCC.V3d import V3d_ZBUFFER
-from OCC.Aspect import Aspect_TOTP_RIGHT_LOWER
-
-#
-# On Windows, the CSF_GraphicShr env variable must be set up
-# and point to the TKOpenGl.dll library.
-#
-if sys.platform == "win32":  # all of this is win specific
-    # if the CSF_GraphicShr variable is not set
-    # it should point to the TKOpenGl.dll library that is shipped with pythonocc binary
-    if not "CSF_GraphicShr" in os.environ:
-        os.environ["CSF_GraphicShr"] = os.path.join(os.path.dirname(OCC.Aspect.__file__), "TKOpenGl.dll")
+                               Quantity_NOC_BLACK, Quantity_NOC_BLUE1,
+                               Quantity_NOC_CYAN1, Quantity_NOC_RED,
+                               Quantity_NOC_GREEN, Quantity_NOC_ORANGE, Quantity_NOC_YELLOW)
+from OCC.Prs3d import Prs3d_Arrow, Prs3d_Presentation, Prs3d_Text, Prs3d_TextAspect
+from OCC.Graphic3d import (Graphic3d_NOM_NEON_GNC, Graphic3d_NOT_ENV_CLOUDS,
+                                Handle_Graphic3d_TextureEnv, Graphic3d_TextureEnv,
+                                Graphic3d_Camera, Graphic3d_RM_RAYTRACING,
+                                Graphic3d_RM_RASTERIZATION,
+                                Graphic3d_RenderingParams)
+from OCC.Aspect import Aspect_TOTP_RIGHT_LOWER, Aspect_FM_STRETCH, Aspect_FM_NONE
+
+# Shaders and Units definition must be found by occ
+# the fastest way to get done is to set the CASROOT env variable
+# it must point to the /share folder.
+if sys.platform == "win32":
+    # do the same for Units
+    if "CASROOT" in os.environ:
+        casroot_path = os.environ["CASROOT"]
+        # raise an error, force the user to correctly set the variable
+        err_msg = "Please set the CASROOT env variable (%s is not ok)" % casroot_path
+        if not os.path.isdir(casroot_path):
+        	raise AssertionError(err_msg)
+    else:  # on miniconda or anaconda or whatever conda
+        occ_package_path = os.path.dirname(OCC.__file__)
+        casroot_path = os.path.join(occ_package_path, '..', '..', '..',
+                                    'Library', 'share', 'oce')
+        # we check that all required files are at the right place
+        shaders_dict_found = os.path.isdir(os.path.join(casroot_path,
+                                                        'src', 'Shaders'))
+        unitlexicon_found = os.path.isfile(os.path.join(casroot_path,
+                                                        'src', 'UnitsAPI',
+                                                        'Lexi_Expr.dat'))
+        unitsdefinition_found = os.path.isfile(os.path.join(casroot_path,
+                                                            'src', 'UnitsAPI',
+                                                            'Units.dat'))
+        if shaders_dict_found and unitlexicon_found and unitsdefinition_found:
+            os.environ["CASROOT"] = casroot_path
 
 
 def rgb_color(r, g, b):
@@ -73,7 +97,6 @@ def get_color_from_name(color_name):
     enum_name = 'Quantity_NOC_%s' % color_name.upper()
     if enum_name in globals():
         color_num = globals()[enum_name]
-        return Quantity_Color(color_num)
     elif enum_name+'1' in globals():
         color_num = globals()[enum_name+'1']
         print('Many colors for color name %s, using first.' % color_name)
@@ -92,9 +115,10 @@ modes = itertools.cycle([TopAbs_FACE, TopAbs_EDGE,
                          TopAbs_SHELL, TopAbs_SOLID])
 
 
-class Viewer3d(OCC.Visualization.Display3d):
-    def __init__(self, window_handle):
-        OCC.Visualization.Display3d.__init__(self)
+class Viewer3d(Display3d):
+    def __init__(self, window_handle, parent=None):
+        Display3d.__init__(self)
+        self._parent = parent  # the parent opengl GUI container
         self._window_handle = window_handle
         self._inited = False
         self._local_context_opened = False
@@ -104,11 +128,27 @@ class Viewer3d(OCC.Visualization.Display3d):
         self.Context = None
         self.Viewer = None
         self.View = None
-        self.selected_shape = None
+        self.OverLayer = None
         self.default_drawer = None
         self._struc_mgr = None
+        self._is_offscreen = None
+
         self.selected_shapes = []
         self._select_callbacks = []
+        self._overlay_items = []
+
+    def get_parent(self):
+        return self._parent
+
+    def register_overlay_item(self, overlay_item):
+        self._overlay_items.append(overlay_item)
+        self.View.MustBeResized()
+        self.View.Redraw()
+
+    def GetOverLayer(self):
+        """ returns an handle to the current overlayer
+        """
+        return self.OverLayer
 
     def register_select_callback(self, callback):
         """ Adds a callback that will be called each time a shape s selected
@@ -134,7 +174,11 @@ class Viewer3d(OCC.Visualization.Display3d):
         self.View.FitAll()
 
     def Create(self, create_default_lights=True, draw_face_boundaries=True, phong_shading=True):
-        self.Init(self._window_handle)
+        if self._window_handle is None:
+            self.InitOffscreen(640, 480)
+            self._is_offscreen = True
+        else:
+            self.Init(self._window_handle)
         self.Context_handle = self.GetContext()
         self.Viewer_handle = self.GetViewer()
         self.View_handle = self.GetView()
@@ -156,21 +200,28 @@ class Viewer3d(OCC.Visualization.Display3d):
         self.default_drawer.SetMaximalChordialDeviation(chord_dev)
 
         if phong_shading:
-            # gouraud shading by defauly, prefer phong instead
-            self.View.SetShadingModel(OCC.V3d.V3d_PHONG)
+            # gouraud shading by default, prefer phong instead
+            self.View.SetShadingModel(V3d_PHONG)
 
         # the selected elements gray by default, better to use orange...
         # self.Context.SelectionColor(Quantity_NOC_ORANGE)
 
-        # nessecary for text rendering
+        # necessary for text rendering
         self._struc_mgr = self.Context.MainPrsMgr().GetObject().StructureManager()
-        self._inited = True
 
-    def SetDoubleBuffer(self, on_or_off):
-        """enables double buffering when shapes are moved in the viewer
-        a very shaky picture is drawn, since double buffering
-        is disabled by default. fixed here..."""
-        self.View.Window().GetObject().SetDoubleBuffer(bool(on_or_off))
+        # overlayer
+        self.OverLayer = self.Viewer.Viewer().GetObject().OverLayer().GetObject()
+        if self.OverLayer is None:
+            aMgr = V3d_LayerMgr(self.View.GetHandle())
+            self.OverLayer = aMgr.Overlay().GetObject()
+            self.View.SetLayerMgr(aMgr.GetHandle())
+        print("Layer manager created")
+        height, width = self.View.Window().GetObject().Size()
+        print("Layer dimensions: %i, %i" % (height, width))
+        self.OverLayer.SetViewport(height, width)
+
+        # turn self._inited flag to True
+        self._inited = True
 
     def OnResize(self):
         self.View.MustBeResized()
@@ -179,68 +230,138 @@ class Viewer3d(OCC.Visualization.Display3d):
         self.View.Reset()
 
     def Repaint(self):
+        # overlayed objects
+        self.OverLayer.Begin()
+        for item in self._overlay_items:
+            item.RedrawLayerPrs()
+        self.OverLayer.End()
+        # finally redraw the view
         self.Viewer.Redraw()
 
     def SetModeWireFrame(self):
         self.View.SetComputedMode(False)
-        self.Context.SetDisplayMode(OCC.AIS.AIS_WireFrame)
+        self.Context.SetDisplayMode(AIS_WireFrame)
 
     def SetModeShaded(self):
         self.View.SetComputedMode(False)
-        self.Context.SetDisplayMode(OCC.AIS.AIS_Shaded)
-        self.EnableAntiAliasing()
+        self.Context.SetDisplayMode(AIS_Shaded)
 
     def SetModeHLR(self):
         self.View.SetComputedMode(True)
 
-    def SetOrthographic(self, _bool):
-        '''
-        sets whether this view is a orthographic or perspective view
-        @param _bool:
-        '''
-        raise AssertionError("SetOrthographic method not yet implemented.")
+    def SetOrthographicProjection(self):
+        self.camera.SetProjectionType(Graphic3d_Camera.Projection_Orthographic)
+
+    def SetPerspectiveProjection(self):
+        self.camera.SetProjectionType(Graphic3d_Camera.Projection_Perspective)
 
     def View_Top(self):
-        self.View.SetProj(OCC.V3d.V3d_Zpos)
+        self.View.SetProj(V3d_Zpos)
 
     def View_Bottom(self):
-        self.View.SetProj(OCC.V3d.V3d_Zneg)
+        self.View.SetProj(V3d_Zneg)
 
     def View_Left(self):
-        self.View.SetProj(OCC.V3d.V3d_Xneg)
+        self.View.SetProj(V3d_Xneg)
 
     def View_Right(self):
-        self.View.SetProj(OCC.V3d.V3d_Xpos)
+        self.View.SetProj(V3d_Xpos)
 
     def View_Front(self):
-        self.View.SetProj(OCC.V3d.V3d_Yneg)
+        self.View.SetProj(V3d_Yneg)
 
     def View_Rear(self):
-        self.View.SetProj(OCC.V3d.V3d_Ypos)
+        self.View.SetProj(V3d_Ypos)
 
     def View_Iso(self):
-        self.View.SetProj(OCC.V3d.V3d_XposYnegZpos)
+        self.View.SetProj(V3d_XposYnegZpos)
+
+    def EnableTextureEnv(self, name_of_texture=Graphic3d_NOT_ENV_CLOUDS):
+        """ enable environment mapping. Possible modes are
+        Graphic3d_NOT_ENV_CLOUDS
+        Graphic3d_NOT_ENV_CV
+        Graphic3d_NOT_ENV_MEDIT
+        Graphic3d_NOT_ENV_PEARL
+        Graphic3d_NOT_ENV_SKY1
+        Graphic3d_NOT_ENV_SKY2
+        Graphic3d_NOT_ENV_LINES
+        Graphic3d_NOT_ENV_ROAD
+        Graphic3d_NOT_ENV_UNKNOWN
+        """
+        texture_env = Graphic3d_TextureEnv(name_of_texture)
+        self.View.SetTextureEnv(texture_env)
+        self.View.SetSurfaceDetail(V3d_TEX_ENVIRONMENT)
+        self.View.Redraw()
+
+    def DisableTextureEnv(self):
+        self.View.SetSurfaceDetail(V3d_TEX_NONE)
+        a_null_texture = Handle_Graphic3d_TextureEnv()
+        self.View.SetTextureEnv(a_null_texture) # Passing null handle to clear the texture data
+        self.View.Redraw()
+
+    def SetRenderingParams(self,
+                           Method=Graphic3d_RM_RASTERIZATION,
+                           RaytracingDepth=3,
+                           IsShadowEnabled=True,
+                           IsReflectionEnabled=False,
+                           IsAntialiasingEnabled=False,
+                           IsTransparentShadowEnabled=False,
+                           StereoMode=0,
+                           AnaglyphFilter=0,
+                           ToReverseStereo=False):
+        """ Default values are :
+            Method=Graphic3d_RM_RASTERIZATION,
+            RaytracingDepth=3,
+            IsShadowEnabled=True,
+            IsReflectionEnabled=False,
+            IsAntialiasingEnabled=False,
+            IsTransparentShadowEnabled=False,
+            StereoMode=Graphic3d_StereoMode_QuadBuffer,
+            AnaglyphFilter=Graphic3d_RenderingParams.Anaglyph_RedCyan_Optimized,
+            ToReverseStereo=False)
+        """
+        self.ChangeRenderingParams(Method,
+                                   RaytracingDepth,
+                                   IsShadowEnabled,
+                                   IsReflectionEnabled,
+                                   IsAntialiasingEnabled,
+                                   IsTransparentShadowEnabled,
+                                   StereoMode,
+                                   AnaglyphFilter,
+                                   ToReverseStereo)
+
+    def SetRasterizationMode(self):
+        """ to enable rasterization mode, just call the SetRenderingParams
+        with default values
+        """
+        self.SetRenderingParams()
+
+    def SetRaytracingMode(self, depth=3):
+        """ enables the raytracing mode
+        """
+        self.SetRenderingParams(Method=Graphic3d_RM_RAYTRACING,
+                                RaytracingDepth=depth,
+                                IsAntialiasingEnabled=True,
+                                IsShadowEnabled=True,
+                                IsReflectionEnabled=True,
+                                IsTransparentShadowEnabled=True)
 
     def ExportToImage(self, image_filename):
         self.View.Dump(image_filename)
 
-    def set_raytracing_mode(self, shadows=True, reflections=True, antialiasing=True):
-        self.View.SetRaytracingMode()
-        if shadows:
-            self.View.EnableRaytracedShadows()
-        if reflections:
-            self.View.EnableRaytracedReflections()
-        if antialiasing:
-            self.View.EnableRaytracedAntialiasing()
-
     def display_graduated_trihedron(self):
         self.View.GraduatedTrihedronDisplay()
 
     def display_trihedron(self):
-        """ Show a black trihedron in lower right corner
+        """ Show a black triedron in lower right corner
         """
         self.View.TriedronDisplay(Aspect_TOTP_RIGHT_LOWER, Quantity_NOC_BLACK, 0.1, V3d_ZBUFFER)
 
+    def hide_triedron(self):
+        """ Show a black triedron in lower right corner
+        """
+        self.View.TriedronErase()
+
     def set_bg_gradient_color(self, R1, G1, B1, R2, G2, B2):
         """ set a bg vertical gradient color.
         R, G and B are floats.
@@ -250,14 +371,18 @@ class Viewer3d(OCC.Visualization.Display3d):
         self.View.SetBgGradientColors(aColor1, aColor2, 2, True)
 
     def SetBackgroundImage(self, image_filename, stretch=True):
+        """ displays a background image (jpg, png etc.)
+        """
         if not os.path.isfile(image_filename):
             raise IOError("image file %s not found." % image_filename)
         if stretch:
-            self.View.SetBackgroundImage(image_filename, OCC.Aspect.Aspect_FM_STRETCH, True)
+            self.View.SetBackgroundImage(image_filename, Aspect_FM_STRETCH, True)
         else:
-            self.View.SetBackgroundImage(image_filename, OCC.Aspect.Aspect_FM_NONE, True)
+            self.View.SetBackgroundImage(image_filename, Aspect_FM_NONE, True)
 
     def DisplayVector(self, vec, pnt, update=False):
+        """ displays a vector as an arrow
+        """
         if self._inited:
             aPresentation = Prs3d_Presentation(self._struc_mgr)
 
@@ -266,7 +391,7 @@ class Viewer3d(OCC.Visualization.Display3d):
             pnt_start = gp_Pnt(start.X(), start.Y(), start.Z())
 
             Prs3d_Arrow.Draw(
-                aPresentation.GetHandle(),
+                aPresentation,
                 pnt_start,
                 gp_Dir(vec),
                 math.radians(20),
@@ -294,8 +419,8 @@ class Viewer3d(OCC.Visualization.Display3d):
             text_aspect.SetHeight(height)
         if isinstance(point, gp_Pnt2d):
             point = gp_Pnt(point.X(), point.Y(), 0)
-        Prs3d_Text.Draw(aPresentation.GetHandle(),
-                        text_aspect.GetHandle(),
+        Prs3d_Text.Draw(aPresentation,
+                        text_aspect,
                         to_string(text_to_write),
                         point)
         aPresentation.Display()
@@ -306,8 +431,9 @@ class Viewer3d(OCC.Visualization.Display3d):
         return aPresentation
 
     def DisplayShape(self, shapes, material=None, texture=None, color=None, transparency=None, update=False):
-        '''
-        '''
+        """ display one or a set of displayable objects
+        """
+        SOLO = False  # assume multiple instances by default
         # if a gp_Pnt is passed, first convert to vertex
         if issubclass(shapes.__class__, gp_Pnt):
             vertex = BRepBuilderAPI_MakeVertex(shapes)
@@ -355,16 +481,14 @@ class Viewer3d(OCC.Visualization.Display3d):
         elif issubclass(shapes.__class__, TopoDS_Shape):
             shapes = [shapes]
             SOLO = True
-        else:
-            SOLO = False
 
         ais_shapes = []
 
         for shape in shapes:
             if material or texture:
                 if texture:
-                    self.View.SetSurfaceDetail(OCC.V3d.V3d_TEX_ALL)
-                    shape_to_display = OCC.AIS.AIS_TexturedShape(shape)
+                    self.View.SetSurfaceDetail(V3d_TEX_ALL)
+                    shape_to_display = AIS_TexturedShape(shape)
                     filename, toScaleU, toScaleV, toRepeatU, toRepeatV, originU, originV = texture.GetProperties()
                     shape_to_display.SetTextureFileName(TCollection_AsciiString(filename))
                     shape_to_display.SetTextureMapOn()
@@ -386,10 +510,14 @@ class Viewer3d(OCC.Visualization.Display3d):
             # computing graphic properties is expensive
             # if an iterable is found, so cluster all TopoDS_Shape under
             # an AIS_MultipleConnectedInteractive
-            shape_to_display = AIS_MultipleConnectedInteractive()
-            for i in ais_shapes:
-                shape_to_display.Connect(i)
-
+            #shape_to_display = AIS_MultipleConnectedInteractive()
+            for ais_shp in ais_shapes:
+                # TODO : following line crashes with oce-0.18
+                # why ? fix ?
+                #shape_to_display.Connect(i)
+                self.Context.Display(ais_shp, False)
+            shape_to_display = ais_shapes
+            return shape_to_display
         # set the graphic properties
         if material is None:
             #The default material is too shiny to show the object
@@ -411,10 +539,7 @@ class Viewer3d(OCC.Visualization.Display3d):
         else:
             self.Context.Display(shape_to_display.GetHandle(), False)
 
-        if SOLO:
-            return ais_shapes[0]
-        else:
-            return shape_to_display
+        return shape_to_display
 
     def DisplayColoredShape(self, shapes, color='YELLOW', update=False, ):
         if isinstance(color, str):
@@ -464,13 +589,13 @@ class Viewer3d(OCC.Visualization.Display3d):
         self.Context.UpdateSelected()
 
     def SetSelectionModeVertex(self):
-        self.SetSelectionMode(OCC.TopAbs.TopAbs_VERTEX)
+        self.SetSelectionMode(TopAbs_VERTEX)
 
     def SetSelectionModeEdge(self):
-        self.SetSelectionMode(OCC.TopAbs.TopAbs_EDGE)
+        self.SetSelectionMode(TopAbs_EDGE)
 
     def SetSelectionModeFace(self):
-        self.SetSelectionMode(OCC.TopAbs.TopAbs_FACE)
+        self.SetSelectionMode(TopAbs_FACE)
 
     def SetSelectionModeShape(self):
         self.Context.CloseAllContexts()
@@ -544,3 +669,41 @@ class Viewer3d(OCC.Visualization.Display3d):
 
     def StartRotation(self, X, Y):
         self.View.StartRotation(X, Y)
+
+
+class OffscreenRenderer(Viewer3d):
+    """ The offscreen renderer is inherited from Viewer3d.
+    The DisplayShape method is overriden to export to image
+    each time it is called.
+    """
+    def __init__(self, screen_size=(640, 480)):
+        Viewer3d.__init__(self, None)
+        # create the renderer
+        self.Create()
+        self.SetSize(screen_size[0], screen_size[1])
+        self.SetModeShaded()
+        self.set_bg_gradient_color([206, 215, 222], [128, 128, 128])
+        self.display_triedron()
+        self.capture_number = 0
+
+    def DisplayShape(self, shapes, material=None, texture=None, color=None, transparency=None, update=True):
+        # call the "original" DisplayShape method
+        r = super(OffscreenRenderer, self).DisplayShape(shapes, material, texture,
+                                                        color, transparency, update)  # always update
+        if os.getenv("PYTHONOCC_OFFSCREEN_RENDERER_DUMP_IMAGE") == "1":  # dump to jpeg file
+            timestamp = ("%f" % time.time()).split(".")[0]
+            self.capture_number += 1
+            image_filename = "capture-%i-%s.jpeg" % (self.capture_number,
+                                                     timestamp.replace(" ", "-"))
+            if os.getenv("PYTHONOCC_OFFSCREEN_RENDERER_DUMP_IMAGE_PATH"):
+                path = os.getenv("PYTHONOCC_OFFSCREEN_RENDERER_DUMP_IMAGE_PATH")
+                if not os.path.isdir(path):
+                	raise IOError("%s is not a valid path" % path)
+            else:
+                path = os.getcwd()
+            image_full_name = os.path.join(path, image_filename)
+            self.View.Dump(image_full_name)
+            if not os.path.isfile(image_full_name):
+            	raise IOError("OffscreenRenderer failed to render image to file")
+            print("OffscreenRenderer content dumped to %s" % image_full_name)
+        return r
diff --git src/Display/WebGl/jupyter_renderer.py src/Display/WebGl/jupyter_renderer.py
new file mode 100644
index 0000000..07e55d1
--- /dev/null
+++ src/Display/WebGl/jupyter_renderer.py
@@ -0,0 +1,618 @@
+##Copyright 20117-2018 Thomas Paviot (tpaviot@gmail.com)
+##
+##This file is part of pythonOCC.
+##
+##pythonOCC is free software: you can redistribute it and/or modify
+##it under the terms of the GNU Lesser General Public License as published by
+##the Free Software Foundation, either version 3 of the License, or
+##(at your option) any later version.
+##
+##pythonOCC is distributed in the hope that it will be useful,
+##but WITHOUT ANY WARRANTY; without even the implied warranty of
+##MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+##GNU Lesser General Public License for more details.
+##
+##You should have received a copy of the GNU Lesser General Public License
+##along with pythonOCC.  If not, see <http://www.gnu.org/licenses/>.
+
+from __future__ import print_function, absolute_import
+
+import sys
+import enum
+import uuid
+import operator
+from functools import reduce
+
+# pythreejs
+try:
+    from pythreejs import *
+    from IPython.display import display
+    from ipywidgets import HTML, HBox
+    import numpy as np
+except ImportError:
+    error_log = """ Error You must install pythreejs/ipywidgets/numpy to run the jupyter notebook renderer.
+If you installed pythonocc using conda, just type :
+$ conda install -c conda-forge pythreejs"""
+    print(error_log)
+    sys.exit(0)
+
+from OCC.Bnd import Bnd_Box
+from OCC.BRepBndLib import brepbndlib_Add
+from OCC.Visualization import Tesselator
+
+from OCC.Extend.TopologyUtils import TopologyExplorer, is_edge, is_wire, discretize_edge, discretize_wire
+
+# smesh
+try:
+    from OCC.SMESH import SMESH_Mesh
+    HAVE_SMESH = True
+except ImportError:
+    print("SMESH wrapper not found, can't display SMESH meshes")
+    HAVE_SMESH = False
+
+# default values
+
+def format_color(r, g, b):
+    return '#%02x%02x%02x' % (r, g, b)
+
+default_shape_color = format_color(166, 166, 166)
+default_mesh_color = 'white'
+default_edge_color = format_color(0, 0, 0)
+default_selection_material = MeshPhongMaterial(color='orange',
+                                               polygonOffset=True,
+                                               polygonOffsetFactor=1,
+                                               polygonOffsetUnits=1,
+                                               shininess=0.9,
+                                               side='DoubleSide')
+
+class bounding_box(object):
+    """ Representation of the bounding box of the TopoDS_Shape `shape`
+    Constructor Parameters
+    ----------
+    shape : TopoDS_Shape or a subclass such as TopoDS_Face
+        the shape to compute the bounding box from
+    tol: float
+        tolerance of the computed boundingbox
+    """
+
+    def __init__(self, shape_or_values, tol=1.e-5):
+        if isinstance(shape_or_values, tuple):
+            self.values = shape_or_values
+        else:
+            bbox = Bnd_Box()
+            bbox.SetGap(tol)
+            brepbndlib_Add(shape_or_values, bbox, True)  # use the shape triangulation
+            self.values = bbox.Get()
+
+    def __getattr__(self, k):
+        attrs_0 = "x_min", "y_min", "z_min", "x_max", "y_max", "z_max"
+        if k in attrs_0:
+            return self.values[attrs_0.index(k)]
+
+        idx = "xyz".index(k.split('_')[0])
+
+        attrs_1 = "x_size", "y_size", "z_size"
+        if k in attrs_1:
+            return self.values[idx + 3] - self.values[idx]
+
+        attrs_2 = "x_center", "y_center", "z_center"
+        if k in attrs_2:
+            return (self.values[idx] + self.values[idx + 3]) / 2.
+
+        raise AttributeError("bounding_box has no attribute " + k)
+
+    def __add__(self, other):
+        a, b = self.values, other.values
+        mi = tuple(map(min, a[0:3], b[0:3]))
+        ma = tuple(map(max, a[3:6], b[3:6]))
+        return bounding_box(mi + ma)
+
+
+class NORMAL(enum.Enum):
+    SERVER_SIDE = 1
+    CLIENT_SIDE = 2
+
+
+class JupyterRenderer(object):
+    def __init__(self, size=(480, 480), compute_normals_mode=NORMAL.SERVER_SIDE, parallel=False):
+        """ Creates a jupyter renderer.
+        size: a tuple (width, height). Must be a square, or shapes will look like deformed
+        compute_normals_mode: optional, set to SERVER_SIDE by default. This flag lets you choose the
+        way normals are computed. If SERVER_SIDE is selected (default value), then normals
+        will be computed by the Tesselator, packed as a python tuple, and send as a json structure
+        to the client. If, on the other hand, CLIENT_SIDE is chose, then the computer only compute vertex
+        indices, and let the normals be computed by the client (the web js machine embedded in the webrowser).
+
+        * SERVER_SIDE: higher server load, loading time increased, lower client load. Poor performance client will
+          choose this option (mobile terminals for instance)
+        * CLIENT_SIDE: lower server load, loading time decreased, higher client load. Higher performance clients will
+                            choose this option (laptops, desktop machines).
+        * parallel: optional, False by default. If set to True, meshing runs in parallelized mode.
+        """
+        self._background = 'white'
+        self._background_opacity = 1
+        self._size = size
+        self._compute_normals_mode = compute_normals_mode
+        self._parallel = parallel
+
+        self.html = HTML("Selected shape : None")
+        # the default camera object
+        self._camera_target = [0., 0., 0.]  # the point to look at
+        self._camera_position = [0, 0., 100.]  # the camera initial position
+        self._camera = PerspectiveCamera(position=self._camera_position,
+                                         lookAt=self._camera_target,
+                                         up=[0, 0, 1],
+                                         aspect=self._size[0] / self._size[1],
+                                         fov=50,
+                                         children=[DirectionalLight(color='#ffffff', position=[50, 50, 50], intensity=0.9)])
+
+        # a dictionnary of all the shapes belonging to the renderer
+        # each element is a key 'mesh_id:shape'
+        self._shapes = {}
+
+        # the group of 3d and 2d objects to render
+        self._displayed_pickable_objects = Group()
+
+        # the group of other objects (grid, trihedron etc.) that can't e selected
+        self._displayed_non_pickable_objects = Group()
+
+                # event manager/selection manager
+        self._picker = Picker(controlling=self._displayed_pickable_objects, event='mousedown')
+
+        self._controls = OrbitControls(controlling=self._camera, target=self._camera_target);
+
+        # we save the renderer so that is can be accessed
+        self._scene = Scene(children=[self._displayed_pickable_objects,
+                                    self._displayed_non_pickable_objects,
+                                    self._camera,
+                                    AmbientLight(color='#101010')])
+        self._renderer = Renderer(camera=self._camera,
+                                  background=self._background,
+                                  background_opacity=self._background_opacity,
+                                  scene=self._scene,
+                                  controls=[self._controls, self._picker],
+                                  width=self._size[0],
+                                  height=self._size[1],
+                                  antialias=True,
+                                  alpha=True,
+                                  clearOpacity=0)
+
+
+        self._current_shape_selection = None
+        self._current_mesh_selection = None
+        self._current_selection_material = None  # the color of the object currently being rendered
+        self._select_callbacks = []  # a list of all functions called after an object is selected
+
+        self.GRID_ID = "__jupyter_renderer_grid__"
+
+
+        def click(value):
+            """ called whenever a shape  or edge is clicked
+            """
+            obj = value.owner.object
+            if self._current_mesh_selection is not None:
+                self._current_mesh_selection.material = self._current_selection_material
+            if obj is not None:
+                id_clicked = obj.name  # the mesh id clicked
+                self._current_mesh_selection = obj
+                self._current_selection_material = obj.material
+                obj.material = default_selection_material
+                # get the shape from this mesh id
+                selected_shape = self._shapes[id_clicked]
+                self.print_message("<b>Shape id:</b> %s<br><b>Topology hierearchy</b>" % (selected_shape))
+                self._current_shape_selection = selected_shape
+            else:
+                self.print_message("<b>Shape id:</b> None")
+            # then execute calbacks
+            for callback in self._select_callbacks:
+                callback(self._current_shape_selection)
+
+        self._picker.observe(click)
+
+        # key press and related events
+        #def key_pressed(widget):
+        #    print("key pressed")
+        #self._picker2 = Picker(event='keypress')
+        #self._picker.observe(key_pressed)
+
+
+    def print_message(self, text):
+        self.html.value = text
+
+
+    def register_select_callback(self, callback):
+        """ Adds a callback that will be called each time a shape is selected
+        """
+        if not callable(callback):
+            raise AssertionError("You must provide a callable to register the callback")
+        else:
+            self._select_callbacks.append(callback)
+
+
+    def unregister_callback(self, callback):
+        """ Remove a callback from the callback list
+        """
+        if not callback in self._select_callbacks:
+            raise AssertionError("This callback is not registered")
+        else:
+            self._select_callbacks.remove(callback)
+
+
+    def _update_camera(self):
+        all_shapes = list(self._shapes.values())
+        if all_shapes:
+            bb = reduce(operator.add, map(bounding_box, all_shapes))
+            self._camera_target = [bb.x_center, bb.y_center, bb.z_center]
+            self._camera_position = [0, bb.y_center - 2 * bb.y_size, bb.z_center + 2 * bb.z_center]
+        # self._camera.position = self._camera_position
+        self._camera.lookAt = self._camera_target
+        # this is buggy and works better without
+        # self._camera.position  = self._camera_position
+        self._controls.target = self._camera_target
+        self.Update()
+
+
+    def GetSelectedShape(self):
+        """ Returns the selected shape
+        """
+        return self._current_shape_selection
+
+
+    def GridOff(self, update=True):
+        grid = JupyterRenderer._get_object_by_name(self._displayed_non_pickable_objects, self.GRID_ID)
+
+        if grid is not None:
+            self._displayed_non_pickable_objects.remove(grid)
+
+        if update:
+            self.Update()
+
+    def DisplayGrid(self, sizex, sizey, nx, ny, update=True):
+        """ Displays a grid in the renderer.
+        sizex: float, grid size along x axis
+        sizey: float, grid size along y axis
+        nx: integer, number of segments along the x axis
+        ny: integer, number of segments along the y axis
+        """
+
+        self.GridOff(update=False)
+
+        surf_geo = SurfaceGeometry(z=[0] * (nx + 1) * (ny + 1),
+                                   width=sizex,
+                                   height=sizey,
+                                   width_segments=nx,
+                                   height_segments=ny)
+        surf_grid = SurfaceGrid(geometry=surf_geo,
+                                material=LineBasicMaterial(color='#000000',
+                                                           opacity=0.2,
+                                                           transparent=True),
+                                name=self.GRID_ID)
+        self._displayed_non_pickable_objects.add(surf_grid)
+        if update:
+            self.Update()
+
+
+    def DisplayMesh(self,
+                    mesh,
+                    color=default_mesh_color,
+                    update=True):
+        """ Display a MEFISTO2 triangle mesh
+        """
+        if not HAVE_SMESH:
+            print("SMESH not installed, DisplayMesh method unavailable.")
+            return
+        if not isinstance(mesh, SMESH_Mesh):
+            raise AssertionError("You mush provide an SMESH_Mesh instance")
+        mesh_ds = mesh.GetMeshDS()  # the mesh data source
+        face_iter = mesh_ds.facesIterator()
+        # vertices positions are stored to a liste
+        vertices_position = []
+        for _ in range(mesh_ds.NbFaces()-1):
+            face = face_iter.next()
+            #print('Face %i, type %i' % (i, face.GetType()))
+            #print(dir(face))
+            # if face.GetType == 3 : triangle mesh, then 3 nodes
+            for j in range(3):
+                node = face.GetNode(j)
+                #print('Coordinates of node %i:(%f,%f,%f)'%(i, node.X(), node.Y(), node.Z()))
+                vertices_position.append(node.X())
+                vertices_position.append(node.Y())
+                vertices_position.append(node.Z())
+        number_of_vertices = len(vertices_position)
+        # then we build the vertex and faces collections as numpy ndarrays
+        np_vertices = np.array(vertices_position, dtype='float32').reshape(int(number_of_vertices / 3), 3)
+        # Note: np_faces is just [0, 1, 2, 3, 4, 5, ...], thus arange is used
+        np_faces = np.arange(np_vertices.shape[0], dtype='uint32')
+        # set geometry properties
+        buffer_geometry_properties = {'position': BufferAttribute(np_vertices),
+                                      'index'   : BufferAttribute(np_faces)}
+        # build a BufferGeometry instance
+        mesh_geometry = BufferGeometry(attributes=buffer_geometry_properties)
+
+        mesh_geometry.exec_three_obj_method('computeVertexNormals')
+
+        # then a default material
+        mesh_material = MeshPhongMaterial(color=color,
+                                          polygonOffset=True,
+                                          polygonOffsetFactor=1,
+                                          polygonOffsetUnits=1,
+                                          shininess=0.5,
+                                          wireframe=False,
+                                          side='DoubleSide')
+        edges_material = MeshPhongMaterial(color='black',
+                                           polygonOffset=True,
+                                           polygonOffsetFactor=1,
+                                           polygonOffsetUnits=1,
+                                           shininess=0.5,
+                                           wireframe=True)
+        # create a mesh unique id
+        mesh_id = uuid.uuid4().hex
+
+        # finally create the mash
+        shape_mesh = Mesh(geometry=mesh_geometry,
+                          material=mesh_material,
+                          name=mesh_id)
+        edges_mesh = Mesh(geometry=mesh_geometry,
+                          material=edges_material,
+                          name=mesh_id)
+
+        self._displayed_pickable_objects.add(shape_mesh)
+        self._displayed_non_pickable_objects.add(edges_mesh)
+
+        if update:
+            self.Update()
+
+
+    def DisplayShape(self,
+                     shp,  # the TopoDS_Shape to be displayed
+                     shape_color=default_shape_color,  # the default
+                     render_edges=False,
+                     edge_color=default_edge_color,
+                     compute_uv_coords=False,
+                     quality=1.0,
+                     transparency=False,
+                     opacity=1.,
+                     topo_level='default',
+                     update=False):
+        """ Displays a topods_shape in the renderer instance.
+        shp: the TopoDS_Shape to render
+        shape_color: the shape color, in html corm, eg '#abe000'
+        render_edges: optional, False by default. If True, compute and dislay all
+                      edges as a linear interpolation of segments.
+        edge_color: optional, black by default. The color used for edge rendering,
+                    in html form eg '#ff00ee'
+        compute_uv_coords: optional, false by default. If True, compute texture
+                           coordinates (required if the shape has to be textured)
+        quality: optional, 1.0 by default. If set to something lower than 1.0,
+                      mesh will be more precise. If set to something higher than 1.0,
+                      mesh will be less precise, i.e. lower numer of triangles.
+        transparency: optional, False by default (opaque).
+        opacity: optional, float, by default to 1 (opaque). if transparency is set to True,
+                 0. is fully opaque, 1. is fully transparent.
+        topo_level: "default" by default. The value should be either "compound", "shape", "vertex".
+        update: optional, False by default. If True, render all the shapes.
+        """
+        if is_wire(shp) or is_edge(shp):
+            self.AddCurveToScene(shp, shape_color, quality=quality)
+        if topo_level != "default":
+            t = TopologyExplorer(shp)
+            map_type_and_methods = {"Solid": t.solids, "Face": t.faces, "Shell": t.shells,
+                                    "Compound": t.compounds, "Compsolid": t.comp_solids}
+            for subshape in map_type_and_methods[topo_level]():
+                self.AddShapeToScene(subshape, shape_color, render_edges, edge_color, compute_uv_coords, quality,
+                                     transparency, opacity)
+        else:
+            self.AddShapeToScene(shp, shape_color, render_edges, edge_color, compute_uv_coords, quality,
+                                 transparency, opacity)
+
+        self._update_camera()
+        self._renderer.render(self._scene, self._camera)
+        if update:
+            self.Display()
+
+    def DisplayPoints(self, pointsArray, update=True, color='red', size=11, name='_vertices_'):
+        vertex_mesh = self._create_vertices_mesh(pointsArray, color=color, size=size)
+        vertex_mesh.name = name
+        self._displayed_non_pickable_objects.add(vertex_mesh)
+
+        if update:
+            self.Update()
+
+
+    def AddCurveToScene(self, shp, color, quality=0.5):
+        """ shp is either a TopoDS_Wire or a TopodS_Edge.
+        """
+        if is_edge(shp):
+            pnts = discretize_edge(shp, quality)
+        elif is_wire(shp):
+            pnts = discretize_wire(shp, quality)
+        np_edge_vertices = np.array(pnts, dtype=np.float32)
+        np_edge_indices = np.arange(np_edge_vertices.shape[0], dtype=np.uint32)
+        edge_geometry = BufferGeometry(attributes={
+            'position': BufferAttribute(np_edge_vertices),
+            'index'   : BufferAttribute(np_edge_indices)
+        })
+        edge_material = LineBasicMaterial(color=color, linewidth=2, fog=True)
+        edge_lines = Line(geometry=edge_geometry, material=edge_material)
+        mesh_id = "%d" % shp.HashCode(2147483647)
+        edge_lines.name = mesh_id
+        self._shapes[mesh_id] = shp
+
+        # Add geometries to pickable or non pickable objects
+        self._displayed_pickable_objects.add(edge_lines)
+
+
+    def AddShapeToScene(self,
+                        shp,  # the TopoDS_Shape to be displayed
+                        shape_color=default_shape_color,  # the default
+                        render_edges=False,
+                        edge_color=default_edge_color,
+                        compute_uv_coords=False,
+                        quality=1.0,
+                        transparency=False,
+                        opacity=1.):
+        # first, compute the tesselation
+        tess = Tesselator(shp)
+        tess.Compute(uv_coords=compute_uv_coords,
+                     compute_edges=render_edges,
+                     mesh_quality=quality,
+                     parallel=self._parallel)
+        # get vertices and normals
+        vertices_position = tess.GetVerticesPositionAsTuple()
+
+        number_of_triangles = tess.ObjGetTriangleCount()
+        number_of_vertices = len(vertices_position)
+
+        # number of vertices should be a multiple of 3
+        if number_of_vertices % 3 != 0:
+            raise AssertionError("Wrong number of vertices")
+        if number_of_triangles * 9 != number_of_vertices:
+            raise AssertionError("Wrong number of triangles")
+
+        # then we build the vertex and faces collections as numpy ndarrays
+        np_vertices = np.array(vertices_position, dtype='float32').reshape(int(number_of_vertices / 3), 3)
+        # Note: np_faces is just [0, 1, 2, 3, 4, 5, ...], thus arange is used
+        np_faces = np.arange(np_vertices.shape[0], dtype='uint32')
+
+        # set geometry properties
+        buffer_geometry_properties = {'position': BufferAttribute(np_vertices),
+                                      'index'   : BufferAttribute(np_faces)}
+        if self._compute_normals_mode == NORMAL.SERVER_SIDE:
+            # get the normal list, converts to a numpy ndarray. This should not raise
+            # any issue, since normals have been computed by the server, and are available
+            # as a list of floats
+            np_normals = np.array(tess.GetNormalsAsTuple(), dtype='float32').reshape(-1, 3)
+            # quick check
+            if np_normals.shape != np_vertices.shape:
+                raise AssertionError("Wrong number of normals/shapes")
+            buffer_geometry_properties['normal'] = BufferAttribute(np_normals)
+
+        # build a BufferGeometry instance
+        shape_geometry = BufferGeometry(attributes=buffer_geometry_properties)
+
+        # if the client has to render normals, add the related js instructions
+        if self._compute_normals_mode == NORMAL.CLIENT_SIDE:
+            shape_geometry.exec_three_obj_method('computeVertexNormals')
+
+        # then a default material
+        shp_material = MeshPhongMaterial(color=shape_color,
+                                         polygonOffset=True,
+                                         polygonOffsetFactor=1,
+                                         polygonOffsetUnits=1,
+                                         shininess=0.9,
+                                         transparent=transparency,
+                                         opacity=opacity,
+                                         side='DoubleSide')
+
+        # create a mesh unique id
+        mesh_id = "%d" % shp.HashCode(2147483647)
+
+        # finally create the mash
+        shape_mesh = Mesh(geometry=shape_geometry,
+                          material=shp_material,
+                          name=mesh_id)
+
+
+        # and to the dict of shapes, to have a mapping between meshes and shapes
+        self._shapes[mesh_id] = shp
+
+        # edge rendering, if set to True
+        edge_lines = None
+        if render_edges:
+            edges = list(map(lambda i_edge: [tess.GetEdgeVertex(i_edge, i_vert) for i_vert in range(tess.ObjEdgeGetVertexCount(i_edge))], range(tess.ObjGetEdgeCount())))
+            edges = list(filter(lambda edge: len(edge) == 2, edges))
+            np_edge_vertices = np.array(edges, dtype=np.float32).reshape(-1, 3)
+            np_edge_indices = np.arange(np_edge_vertices.shape[0], dtype=np.uint32)
+            edge_geometry = BufferGeometry(attributes={
+                'position': BufferAttribute(np_edge_vertices),
+                'index'   : BufferAttribute(np_edge_indices)
+            })
+            edge_material = LineBasicMaterial(color=edge_color, linewidth=1)
+            edge_lines = LineSegments(geometry=edge_geometry, material=edge_material, name=mesh_id)
+
+        # Add geometries to pickable or non pickable objects
+        self._displayed_pickable_objects.add(shape_mesh)
+        if render_edges:
+            self._displayed_non_pickable_objects.add(edge_lines)
+
+
+    @staticmethod
+    def _get_object_by_name(group, name):
+        for child in group.children:
+            if name == child.name:
+                return child
+        return None
+
+    def EraseObject(self, objectName, update=True):
+        obj = self._get_object_by_name(self._displayed_pickable_objects, objectName)
+        if obj is not None:
+            self._displayed_pickable_objects.remove(obj)
+
+        obj = self._get_object_by_name(self._displayed_non_pickable_objects, objectName)
+        if obj is not None:
+            self._displayed_non_pickable_objects.remove(obj)
+
+        if update:
+            self.Update()
+
+
+    def EraseShape(self, shape, update=True):
+        mesh_id = "%d" % shape.HashCode(2147483647)
+        self.EraseObject(mesh_id, update=update)
+
+
+    def EraseAll(self, update=True):
+        self._shapes = {}
+        for child in self._displayed_pickable_objects.children:
+            self._displayed_pickable_objects.remove(child)
+        for child in self._displayed_non_pickable_objects.children:
+            self._displayed_non_pickable_objects.remove(child)
+
+        self._current_shape_selection = None
+        self._current_mesh_selection = None
+        self._current_selection_material = None
+
+        if update:
+            self.Update()
+
+    def _create_vertices_mesh(self, vertex_array, color='black', size=9):
+        
+        def gen_cross_texture(size=7):
+            texture = np.zeros((size, size, 4), dtype=np.float32)
+            idx = np.arange(0,size)
+            texture[size//2, idx, :] = 1
+            texture[idx, size//2, :] = 1
+
+            data_tex = DataTexture(data=texture, format="RGBAFormat", type="FloatType")
+
+            return data_tex
+        
+        vertex_array = np.array(vertex_array)
+        
+        attributes = dict(
+            position = BufferAttribute(np.asarray(vertex_array, dtype=np.float32), normalized=False),
+        )
+
+        mat = PointsMaterial(color=color, sizeAttenuation=False, size=size)
+        mat.map = gen_cross_texture(size)
+        mat.alphaTest = 0.6
+
+
+        geom = BufferGeometry(attributes=attributes)
+        mesh_obj = Points(geometry=geom, material=mat)
+        
+        return mesh_obj
+
+    def Update(self):
+        self._renderer.render(self._scene, self._camera)
+
+    def Display(self):
+        self.Update()
+
+        # then display both 3d widgets and webui
+        display(HBox([self._renderer, self.html]))
+
+
+    def __repr__(self):
+        self.Display()
+        return ""
diff --git src/Extend/DataExchange.py src/Extend/DataExchange.py
new file mode 100644
index 0000000..140f4ce
--- /dev/null
+++ src/Extend/DataExchange.py
@@ -0,0 +1,461 @@
+##Copyright 2018 Thomas Paviot (tpaviot@gmail.com)
+##
+##This file is part of pythonOCC.
+##
+##pythonOCC is free software: you can redistribute it and/or modify
+##it under the terms of the GNU Lesser General Public License as published by
+##the Free Software Foundation, either version 3 of the License, or
+##(at your option) any later version.
+##
+##pythonOCC is distributed in the hope that it will be useful,
+##but WITHOUT ANY WARRANTY; without even the implied warranty of
+##MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+##GNU Lesser General Public License for more details.
+##
+##You should have received a copy of the GNU Lesser General Public License
+##along with pythonOCC.  If not, see <http://www.gnu.org/licenses/>.
+
+import os
+
+from OCC.TopoDS import TopoDS_Shape
+from OCC.BRepMesh import BRepMesh_IncrementalMesh
+from OCC.StlAPI import StlAPI_Reader, StlAPI_Writer
+from OCC.BRep import BRep_Builder
+from OCC.TopoDS import TopoDS_Compound
+from OCC.IGESControl import IGESControl_Reader, IGESControl_Writer
+from OCC.STEPControl import STEPControl_Reader, STEPControl_Writer, STEPControl_AsIs
+from OCC.Interface import Interface_Static_SetCVal
+from OCC.IFSelect import IFSelect_RetDone, IFSelect_ItemsByEntity
+from OCC.TDocStd import TDocStd_Document
+from OCC.XCAFDoc import (XCAFDoc_DocumentTool_ShapeTool,
+                              XCAFDoc_DocumentTool_ColorTool)
+from OCC.STEPCAFControl import STEPCAFControl_Reader
+from OCC.TDF import TDF_LabelSequence, TDF_Label, TDF_Tool
+from OCC.TDataStd import TDataStd_Name, TDataStd_Name_GetID
+from OCC.TCollection import TCollection_ExtendedString, TCollection_AsciiString
+from OCC.Quantity import Quantity_Color, Quantity_TOC_RGB
+from OCC.TopLoc import TopLoc_Location
+from OCC.BRepBuilderAPI import BRepBuilderAPI_Transform
+
+from OCC.Extend.TopologyUtils import TopologyExplorer
+
+
+##########################
+# Step import and export #
+##########################
+def read_step_file(filename, return_as_shapes=False, verbosity=True):
+    """ read the STEP file and returns a compound
+    filename: the file path
+    return_as_shapes: optional, False by default. If True returns a list of shapes,
+                      else returns a single compound
+    verbosity: optional, False by default.
+    """
+    if not os.path.isfile(filename):
+        raise FileNotFoundError("%s not found." % filename)
+
+    step_reader = STEPControl_Reader()
+    status = step_reader.ReadFile(filename)
+
+    if status == IFSelect_RetDone:  # check status
+        if verbosity:
+            failsonly = False
+            step_reader.PrintCheckLoad(failsonly, IFSelect_ItemsByEntity)
+            step_reader.PrintCheckTransfer(failsonly, IFSelect_ItemsByEntity)
+        transfer_result = step_reader.TransferRoot(1)
+        if not transfer_result:
+            raise AssertionError("Transfer failed.")
+        _nbs = step_reader.NbShapes()
+        if _nbs != 1:
+            raise AssertionError("Number of shapes is not one.")
+        shape_to_return = step_reader.Shape(1)  # a compound
+        if shape_to_return.IsNull():
+            raise AssertionError("Shape is null.")
+    else:
+        raise AssertionError("Error: can't read file.")
+    if return_as_shapes:
+        shape_to_return = TopologyExplorer(shape_to_return).solids()
+
+    return shape_to_return
+
+
+def write_step_file(a_shape, filename, application_protocol="AP203"):
+    """ exports a shape to a STEP file
+    a_shape: the topods_shape to export (a compound, a solid etc.)
+    filename: the filename
+    application protocol: "AP203" or "AP214"
+    """
+    # a few checks
+    if a_shape.IsNull():
+        raise AssertionError("Shape %s is null." % a_shape)
+    if application_protocol not in ["AP203", "AP214IS"]:
+        raise AssertionError("application_protocol must be either AP203 or AP214IS. You passed %s." % application_protocol)
+    if os.path.isfile(filename):
+        print("Warning: %s file already exists and will be replaced" % filename)
+    # creates and initialise the step exporter
+    step_writer = STEPControl_Writer()
+    Interface_Static_SetCVal("write.step.schema", application_protocol)
+
+    # transfer shapes and write file
+    step_writer.Transfer(a_shape, STEPControl_AsIs)
+    status = step_writer.Write(filename)
+
+    if not status == IFSelect_RetDone:
+        raise AssertionError("Error while writing shape to STEP file.")
+    if not os.path.isfile(filename):
+        raise AssertionError("File %s was not saved to filesystem." % filename)
+
+
+def read_step_file_with_names_colors(filename):
+    """ Returns list of tuples (topods_shape, label, color)
+    Use OCAF.
+    """
+    if not os.path.isfile(filename):
+        raise FileNotFoundError("%s not found." % filename)
+    # the list:
+    output_shapes = {}
+
+    # create an handle to a document
+    doc = TDocStd_Document(TCollection_ExtendedString("pythonocc-doc"))
+
+    # Get root assembly
+    shape_tool = XCAFDoc_DocumentTool_ShapeTool(doc.Main())
+    color_tool = XCAFDoc_DocumentTool_ColorTool(doc.Main())
+    #layer_tool = XCAFDoc_DocumentTool_LayerTool(doc.Main())
+    #mat_tool = XCAFDoc_DocumentTool_MaterialTool(doc.Main())
+
+    step_reader = STEPCAFControl_Reader()
+    step_reader.SetColorMode(True)
+    step_reader.SetLayerMode(True)
+    step_reader.SetNameMode(True)
+    step_reader.SetMatMode(True)
+    step_reader.SetGDTMode(True)
+
+    status = step_reader.ReadFile(filename)
+    if status == IFSelect_RetDone:
+        step_reader.Transfer(doc)
+
+
+    #lvl = 0
+    locs = []
+    #cnt = 0
+
+    def _get_label_name(lab):
+        entry = TCollection_AsciiString()
+        TDF_Tool.Entry(lab, entry)
+        n = TDataStd_Name()
+        lab.FindAttribute(TDataStd_Name_GetID(), n)
+        if n is not None:
+            return n.Get().PrintToString()
+        return "No Name"
+
+    def _get_sub_shapes(lab, loc):
+        #global cnt, lvl
+        #cnt += 1
+        #print("\n[%d] level %d, handling LABEL %s\n" % (cnt, lvl, _get_label_name(lab)))
+        #print()
+        #print(lab.DumpToString())
+        #print()
+        #print("Is Assembly    :", shape_tool.IsAssembly(lab))
+        #print("Is Free        :", shape_tool.IsFree(lab))
+        #print("Is Shape       :", shape_tool.IsShape(lab))
+        #print("Is Compound    :", shape_tool.IsCompound(lab))
+        #print("Is Component   :", shape_tool.IsComponent(lab))
+        #print("Is SimpleShape :", shape_tool.IsSimpleShape(lab))
+        #print("Is Reference   :", shape_tool.IsReference(lab))
+
+        #users = TDF_LabelSequence()
+        #users_cnt = shape_tool.GetUsers(lab, users)
+        #print("Nr Users       :", users_cnt)
+
+        l_subss = TDF_LabelSequence()
+        shape_tool.GetSubShapes(lab, l_subss)
+        #print("Nb subshapes   :", l_subss.Length())
+        l_comps = TDF_LabelSequence()
+        shape_tool.GetComponents(lab, l_comps)
+        #print("Nb components  :", l_comps.Length())
+        #print()
+        name = _get_label_name(lab)
+        print("Name :", name)
+
+        if shape_tool.IsAssembly(lab):
+            l_c = TDF_LabelSequence()
+            shape_tool.GetComponents(lab, l_c)
+            for i in range(l_c.Length()):
+                label = l_c.Value(i+1)
+                if shape_tool.IsReference(label):
+                    #print("\n########  reference label :", label)
+                    label_reference = TDF_Label()
+                    shape_tool.GetReferredShape(label, label_reference)
+                    loc = shape_tool.GetLocation(label)
+                    #print("    loc          :", loc)
+                    #trans = loc.Transformation()
+                    #print("    tran form    :", trans.Form())
+                    #rot = trans.GetRotation()
+                    #print("    rotation     :", rot)
+                    #print("    X            :", rot.X())
+                    #print("    Y            :", rot.Y())
+                    #print("    Z            :", rot.Z())
+                    #print("    W            :", rot.W())
+                    #tran = trans.TranslationPart()
+                    #print("    translation  :", tran)
+                    #print("    X            :", tran.X())
+                    #print("    Y            :", tran.Y())
+                    #print("    Z            :", tran.Z())
+
+                    locs.append(loc)
+                    #print(">>>>")
+                    #lvl += 1
+                    _get_sub_shapes(label_reference, loc)
+                    #lvl -= 1
+                    #print("<<<<")
+                    locs.pop()
+
+        elif shape_tool.IsSimpleShape(lab):
+            #print("\n########  simpleshape label :", lab)
+            shape = shape_tool.GetShape(lab)
+            #print("    all ass locs   :", locs)
+
+            loc = TopLoc_Location()
+            for l in locs:
+                #print("    take loc       :", l)
+                loc = loc.Multiplied(l)
+
+            #trans = loc.Transformation()
+            #print("    FINAL loc    :")
+            #print("    tran form    :", trans.Form())
+            #rot = trans.GetRotation()
+            #print("    rotation     :", rot)
+            #print("    X            :", rot.X())
+            #print("    Y            :", rot.Y())
+            #print("    Z            :", rot.Z())
+            #print("    W            :", rot.W())
+            #tran = trans.TranslationPart()
+            #print("    translation  :", tran)
+            #print("    X            :", tran.X())
+            #print("    Y            :", tran.Y())
+            #print("    Z            :", tran.Z())
+            c = Quantity_Color(0.5, 0.5, 0.5, Quantity_TOC_RGB)  # default color
+            colorSet = False
+            if (color_tool.GetInstanceColor(shape, 0, c) or
+                    color_tool.GetInstanceColor(shape, 1, c) or
+                    color_tool.GetInstanceColor(shape, 2, c)):
+                for i in (0, 1, 2):
+                    color_tool.SetInstanceColor(shape, i, c)
+                colorSet = True
+                n = c.Name(c.Red(), c.Green(), c.Blue())
+                #print('    instance color Name & RGB: ', c, n, c.Red(), c.Green(), c.Blue())
+
+            if not colorSet:
+                if (color_tool.GetColor(lab, 0, c) or
+                        color_tool.GetColor(lab, 1, c) or
+                        color_tool.GetColor(lab, 2, c)):
+                    for i in (0, 1, 2):
+                        color_tool.SetInstanceColor(shape, i, c)
+
+                    n = c.Name(c.Red(), c.Green(), c.Blue())
+                    print('    shape color Name & RGB: ', c, n, c.Red(), c.Green(), c.Blue())
+
+                #n = c.Name(c.Red(), c.Green(), c.Blue())
+                #print('    shape color Name & RGB: ', c, n, c.Red(), c.Green(), c.Blue())
+
+            shape_disp = BRepBuilderAPI_Transform(shape, loc.Transformation()).Shape()
+            if not shape_disp in output_shapes:
+                output_shapes[shape_disp] = [_get_label_name(lab), c]
+            for i in range(l_subss.Length()):
+                lab = l_subss.Value(i+1)
+                #print("\n########  simpleshape subshape label :", lab)
+                shape_sub = shape_tool.GetShape(lab)
+
+                c = Quantity_Color(0.5, 0.5, 0.5, Quantity_TOC_RGB)  # default color
+                colorSet = False
+                if (color_tool.GetInstanceColor(shape_sub, 0, c) or
+                        color_tool.GetInstanceColor(shape_sub, 1, c) or
+                        color_tool.GetInstanceColor(shape_sub, 2, c)):
+                    for i in (0, 1, 2):
+                        color_tool.SetInstanceColor(shape_sub, i, c)
+                    colorSet = True
+                    n = c.Name(c.Red(), c.Green(), c.Blue())
+                    #print('    instance color Name & RGB: ', c, n, c.Red(), c.Green(), c.Blue())
+
+                if not colorSet:
+                    if (color_tool.GetColor(lab, 0, c) or
+                            color_tool.GetColor(lab, 1, c) or
+                            color_tool.GetColor(lab, 2, c)):
+                        for i in (0, 1, 2):
+                            color_tool.SetInstanceColor(shape, i, c)
+
+                        n = c.Name(c.Red(), c.Green(), c.Blue())
+                        #print('    shape color Name & RGB: ', c, n, c.Red(), c.Green(), c.Blue())
+                shape_to_disp = BRepBuilderAPI_Transform(shape_sub, loc.Transformation()).Shape()
+                # position the subshape to display
+                if not shape_to_disp in output_shapes:
+                    output_shapes[shape_to_disp] = [_get_label_name(lab), c]
+
+
+    def _get_shapes():
+        labels = TDF_LabelSequence()
+        shape_tool.GetFreeShapes(labels)
+        #global cnt
+        #cnt += 1
+
+        print()
+        print("Number of shapes at root :", labels.Length())
+        print()
+        for i in range(labels.Length()):
+            root_item = labels.Value(i+1)
+            _get_sub_shapes(root_item, None)
+    _get_shapes()
+    return output_shapes
+
+
+#########################
+# STL import and export #
+#########################
+def write_stl_file(a_shape, filename, mode="ascii", linear_deflection=0.9, angular_deflection=0.5):
+    """ export the shape to a STL file
+    Be careful, the shape first need to be explicitely meshed using BRepMesh_IncrementalMesh
+    a_shape: the topods_shape to export
+    filename: the filename
+    mode: optional, "ascii" by default. Can either be "binary"
+    linear_deflection: optional, default to 0.001. Lower, more occurate mesh
+    angular_deflection: optional, default to 0.5. Lower, more accurate_mesh
+    """
+    if a_shape.IsNull():
+        raise AssertionError("Shape is null.")
+    if mode not in ["ascii", "binary"]:
+        raise AssertionError("mode should be either ascii or binary")
+    if os.path.isfile(filename):
+        print("Warning: %s file already exists and will be replaced" % filename)
+    # first mesh the shape
+    mesh = BRepMesh_IncrementalMesh(a_shape, linear_deflection, False, angular_deflection, True)
+    #mesh.SetDeflection(0.05)
+    mesh.Perform()
+    if not mesh.IsDone():
+        raise AssertionError("Mesh is not done.")
+
+    stl_exporter = StlAPI_Writer()
+    if mode == "ascii":
+        stl_exporter.SetASCIIMode(True)
+    else:  # binary, just set the ASCII flag to False
+        stl_exporter.SetASCIIMode(False)
+    stl_exporter.Write(a_shape, filename)
+
+    if not os.path.isfile(filename):
+        raise IOError("File not written to disk.")
+
+
+def read_stl_file(filename):
+    """ opens a stl file, reads the content, and returns a BRep topods_shape object
+    """
+    if not os.path.isfile(filename):
+        raise FileNotFoundError("%s not found." % filename)
+
+    stl_reader = StlAPI_Reader()
+    the_shape = TopoDS_Shape()
+    stl_reader.Read(the_shape, filename)
+
+    if the_shape.IsNull():
+        raise AssertionError("Shape is null.")
+
+    return the_shape
+
+######################
+# IGES import/export #
+######################
+def read_iges_file(filename, return_as_shapes=False, verbosity=False, visible_only=False):
+    """ read the IGES file and returns a compound
+    filename: the file path
+    return_as_shapes: optional, False by default. If True returns a list of shapes,
+                      else returns a single compound
+    verbosity: optionl, False by default.
+    """
+    if not os.path.isfile(filename):
+        raise FileNotFoundError("%s not found." % filename)
+
+    iges_reader = IGESControl_Reader()
+    iges_reader.SetReadVisible(visible_only)
+    status = iges_reader.ReadFile(filename)
+
+    _shapes = []
+
+    if status == IFSelect_RetDone:  # check status
+        if verbosity:
+            failsonly = False
+            iges_reader.PrintCheckLoad(failsonly, IFSelect_ItemsByEntity)
+            iges_reader.PrintCheckTransfer(failsonly, IFSelect_ItemsByEntity)
+        iges_reader.TransferRoots()
+        nbr = iges_reader.NbRootsForTransfer()
+        for n in range(1, nbr+1):
+            nbs = iges_reader.NbShapes()
+            if nbs == 0:
+                print("At least one shape in IGES cannot be transfered")
+            elif nbr == 1 and nbs == 1:
+                a_res_shape = iges_reader.Shape(1)
+                if a_res_shape.IsNull():
+                    print("At least one shape in IGES cannot be transferred")
+                else:
+                    _shapes.append(a_res_shape)
+            else:
+                for i in range(1, nbs+1):
+                    a_shape = iges_reader.Shape(i)
+                    if a_shape.IsNull():
+                        print("At least one shape in STEP cannot be transferred")
+                    else:
+                        _shapes.append(a_shape)
+    # if not return as shapes
+    # create a compound and store all shapes
+    if not return_as_shapes:
+        builder = BRep_Builder()
+        compound = TopoDS_Compound()
+        builder.MakeCompound(compound)
+        for s in _shapes:
+            builder.Add(compound, s)
+        _shapes = compound
+    return _shapes
+
+def write_iges_file(a_shape, filename):
+    """ exports a shape to a STEP file
+    a_shape: the topods_shape to export (a compound, a solid etc.)
+    filename: the filename
+    application protocol: "AP203" or "AP214"
+    """
+    # a few checks
+    if a_shape.IsNull():
+        raise AssertionError("Shape is null.")
+    if os.path.isfile(filename):
+        print("Warning: %s file already exists and will be replaced" % filename)
+    # creates and initialise the step exporter
+    iges_writer = IGESControl_Writer()
+    iges_writer.AddShape(a_shape)
+    status = iges_writer.Write(filename)
+
+    if status != IFSelect_RetDone:
+        raise AssertionError("Not done.")
+    if not os.path.isfile(filename):
+        raise IOError("File not written to disk.")
+
+if __name__ == "__main__":
+    from OCC.BRepPrimAPI import BRepPrimAPI_MakeSphere
+    sphere_shape = BRepPrimAPI_MakeSphere(30.).Shape()
+    write_step_file(sphere_shape, "s_203.stp", application_protocol="AP203")
+    write_step_file(sphere_shape, "s_214.stp", application_protocol="AP214IS")
+    read_step_file("s_203.stp")
+    read_step_file("s_214.stp")
+    read_step_file("s_214.stp", return_as_shapes=True)
+    write_stl_file(sphere_shape, "s_stl_ascii.stl")
+    write_stl_file(sphere_shape, "s_stl_binary.stl", mode="binary")
+    read_stl_file("s_stl_ascii.stl")
+    read_stl_file("s_stl_binary.stl")
+    # improve the precision by a factor 2
+    write_stl_file(sphere_shape, "s_stl_precise_ascii.stl", linear_deflection=0.1, angular_deflection=0.2)
+    read_stl_file("s_stl_precise_ascii.stl")
+    # iges test
+    write_iges_file(sphere_shape, "s_iges.igs")
+    # write IGES with special character
+    write_iges_file(sphere_shape, "sphre.igs")
+    read_iges_file("sphre.igs")
+    read_iges_file("s_iges.igs")
+    read_iges_file("s_iges.igs", return_as_shapes=True)
+    # test step with colors
+    read_step_file_with_names_colors("s_214.stp")
+
diff --git src/Extend/ShapeFactory.py src/Extend/ShapeFactory.py
new file mode 100644
index 0000000..667711c
--- /dev/null
+++ src/Extend/ShapeFactory.py
@@ -0,0 +1,239 @@
+##Copyright 2009-2014 Jelle Ferina (jelleferinga@gmail.com)
+##
+##This file is part of pythonOCC.
+##
+##pythonOCC is free software: you can redistribute it and/or modify
+##it under the terms of the GNU Lesser General Public License as published by
+##the Free Software Foundation, either version 3 of the License, or
+##(at your option) any later version.
+##
+##pythonOCC is distributed in the hope that it will be useful,
+##but WITHOUT ANY WARRANTY; without even the implied warranty of
+##MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+##GNU Lesser General Public License for more details.
+##
+##You should have received a copy of the GNU Lesser General Public License
+##along with pythonOCC.  If not, see <http://www.gnu.org/licenses/>.
+
+from __future__ import absolute_import
+
+from functools import wraps
+from math import radians
+
+from OCC.BRepBndLib import brepbndlib_Add
+from OCC.BRepPrimAPI import BRepPrimAPI_MakeBox, BRepPrimAPI_MakePrism
+from OCC.BRepBuilderAPI import (BRepBuilderAPI_MakeEdge,
+                                     BRepBuilderAPI_MakeVertex,
+                                     BRepBuilderAPI_MakeWire,
+                                     BRepBuilderAPI_MakeFace, BRepBuilderAPI_MakeEdge2d,
+                                     BRepBuilderAPI_Transform)
+from OCC.BRepFill import BRepFill_Filling
+from OCC.Bnd import Bnd_Box
+from OCC.GeomAbs import GeomAbs_C0
+from OCC.GeomAPI import GeomAPI_PointsToBSpline
+from OCC.TColgp import TColgp_Array1OfPnt
+from OCC.gp import gp_Vec, gp_Pnt, gp_Trsf, gp_OX, gp_OY, gp_OZ
+
+
+def make_edge(*args):
+    edge = BRepBuilderAPI_MakeEdge(*args)
+    result = edge.Edge()
+    return result
+
+
+def make_edge2d(*args):
+    edge = BRepBuilderAPI_MakeEdge2d(*args)
+    result = edge.Edge()
+    edge.Delete()
+    return result
+
+
+def make_vertex(*args):
+    vert = BRepBuilderAPI_MakeVertex(*args)
+    result = vert.Vertex()
+    return result
+
+
+def make_n_sided(edges, continuity=GeomAbs_C0):
+    n_sided = BRepFill_Filling()
+    for edg in edges:
+        n_sided.Add(edg, continuity)
+    n_sided.Build()
+    face = n_sided.Face()
+    return face
+
+
+def make_wire(*args):
+    # if we get an iterable, than add all edges to wire builder
+    if isinstance(args[0], (list, tuple)):
+        wire = BRepBuilderAPI_MakeWire()
+        for i in args[0]:
+            wire.Add(i)
+        wire.Build()
+        return wire.Wire()
+    wire = BRepBuilderAPI_MakeWire(*args)
+    return wire.Wire()
+
+
+def make_face(*args):
+    face = BRepBuilderAPI_MakeFace(*args)
+    if not face.IsDone():
+        raise AssertionError("Face not done")
+    result = face.Face()
+    return result
+
+
+class assert_isdone(object):
+    '''
+    raises an assertion error when IsDone() returns false, with the error
+    specified in error_statement
+    '''
+
+    def __init__(self, to_check, error_statement):
+        self.to_check = to_check
+        self.error_statement = error_statement
+
+    def __enter__(self, ):
+        if self.to_check.IsDone():
+            pass
+        else:
+            raise AssertionError(self.error_statement)
+
+    def __exit__(self, type_, value, traceback):
+        pass
+
+
+@wraps(BRepPrimAPI_MakeBox)
+def make_box(*args):
+    box = BRepPrimAPI_MakeBox(*args)
+    box.Build()
+    with assert_isdone(box, 'failed to built a cube...'):
+        return box.Shape()
+
+
+def points_to_bspline(pnts):
+    pts = TColgp_Array1OfPnt(0, len(pnts) - 1)
+    for n, i in enumerate(pnts):
+        pts.SetValue(n, i)
+    crv = GeomAPI_PointsToBSpline(pts)
+    return crv.Curve()
+
+
+def point_list_to_TColgp_Array1OfPnt(li):
+    pts = TColgp_Array1OfPnt(0, len(li) - 1)
+    for n, i in enumerate(li):
+        pts.SetValue(n, i)
+    return pts
+
+
+def get_boundingbox(shape, tol=1e-6, as_vec=False):
+    """ return the bounding box of the TopoDS_Shape `shape`
+
+    Parameters
+    ----------
+
+    shape : TopoDS_Shape or a subclass such as TopoDS_Face
+        the shape to compute the bounding box from
+
+    tol: float
+        tolerance of the computed boundingbox
+
+    as_vec : bool
+        wether to return the lower and upper point of the bounding box as gp_Vec instances
+
+    Returns
+    -------
+        if `as_vec` is True, return a tuple of gp_Vec instances
+         for the lower and another for the upper X,Y,Z values representing the bounding box
+
+        if `as_vec` is False, return a tuple of lower and then upper X,Y,Z values
+         representing the bounding box
+    """
+    bbox = Bnd_Box()
+    bbox.SetGap(tol)
+    brepbndlib_Add(shape, bbox)
+    xmin, ymin, zmin, xmax, ymax, zmax = bbox.Get()
+    if not as_vec:
+        return xmin, ymin, zmin, xmax, ymax, zmax
+    else:
+        return gp_Vec(xmin, ymin, zmin), gp_Vec(xmax, ymax, zmax)
+
+
+def midpoint(pntA, pntB):
+    """ computes the point that lies in the middle between pntA and pntB
+
+    Parameters
+    ----------
+
+    pntA, pntB : gp_Pnt
+
+    Returns
+    -------
+
+    gp_Pnt
+
+    """
+    vec1 = gp_Vec(pntA.XYZ())
+    vec2 = gp_Vec(pntB.XYZ())
+    veccie = (vec1 + vec2) * 0.5
+    return gp_Pnt(veccie.XYZ())
+
+
+def center_boundingbox(shape):
+    """ compute the center point of a TopoDS_Shape, based on its bounding box
+
+    Parameters
+    ----------
+
+    shape : TopoDS_Shape instance or a subclass like TopoDS_Face
+
+    Returns
+    -------
+
+    gp_Pnt
+
+    """
+    xmin, ymin, zmin, xmax, ymax, zmax = get_boundingbox(shape, 1e-6)
+    return midpoint(gp_Pnt(xmin, ymin, zmin), gp_Pnt(xmax, ymax, zmax))
+
+
+def translate_shp(shp, vec, copy=False):
+    trns = gp_Trsf()
+    trns.SetTranslation(vec)
+    brep_trns = BRepBuilderAPI_Transform(shp, trns, copy)
+    brep_trns.Build()
+    return brep_trns.Shape()
+
+
+def rotate_shp_3_axis(shape, rx, ry, rz, unity="deg"):
+    """ Rotate a shape around (O,x), (O,y) and (O,z).
+
+    @param rx_degree : rotation around (O,x)
+    @param ry_degree : rotation around (O,y)
+    @param rz_degree : rotation around (O,z)
+
+    @return : the rotated shape.
+    """
+    if unity == "deg":  # convert angle to radians
+        rx = radians(rx)
+        ry = radians(ry)
+        rz = radians(rz)
+    alpha = gp_Trsf()
+    alpha.SetRotation(gp_OX(), rx)
+    beta = gp_Trsf()
+    beta.SetRotation(gp_OY(), ry)
+    gamma = gp_Trsf()
+    gamma.SetRotation(gp_OZ(), rz)
+    brep_trns = BRepBuilderAPI_Transform(shape, alpha*beta*gamma, False)
+    shp = brep_trns.Shape()
+    return shp
+
+def make_extrusion(face, length, vector=gp_Vec(0., 0., 1.)):
+    ''' creates a extrusion from a face, along the vector vector.
+    with a distance legnth. Note that the normal vector does not
+    necessary be normalized.
+    By default, the extrusion is along the z axis.
+    '''
+    vector.Normalize()
+    vector.Scale(length)
+    return BRepPrimAPI_MakePrism(face, vector).Shape()
diff --git src/Extend/TopologyUtils.py src/Extend/TopologyUtils.py
new file mode 100644
index 0000000..657463e
--- /dev/null
+++ src/Extend/TopologyUtils.py
@@ -0,0 +1,546 @@
+#!/usr/bin/env python
+
+##Copyright 2008-2015 Jelle Feringa (jelleferinga@gmail.com)
+##
+##This file is part of pythonOCC.
+##
+##pythonOCC is free software: you can redistribute it and/or modify
+##it under the terms of the GNU Lesser General Public License as published by
+##the Free Software Foundation, either version 3 of the License, or
+##(at your option) any later version.
+##
+##pythonOCC is distributed in the hope that it will be useful,
+##but WITHOUT ANY WARRANTY; without even the implied warranty of
+##MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+##GNU Lesser General Public License for more details.
+##
+##You should have received a copy of the GNU Lesser General Public License
+##along with pythonOCC.  If not, see <http://www.gnu.org/licenses/>.
+
+from __future__ import print_function
+
+from OCC.BRep import BRep_Tool
+from OCC.BRepTools import BRepTools_WireExplorer
+from OCC.TopAbs import (TopAbs_VERTEX, TopAbs_EDGE, TopAbs_FACE, TopAbs_WIRE,
+                             TopAbs_SHELL, TopAbs_SOLID, TopAbs_COMPOUND,
+                             TopAbs_COMPSOLID)
+from OCC.TopExp import TopExp_Explorer, topexp_MapShapesAndAncestors
+from OCC.TopTools import (TopTools_ListOfShape,
+                               TopTools_ListIteratorOfListOfShape,
+                               TopTools_IndexedDataMapOfShapeListOfShape)
+from OCC.TopoDS import (TopoDS_Wire, TopoDS_Vertex, TopoDS_Edge,
+                             TopoDS_Face, TopoDS_Shell, TopoDS_Solid,
+                             TopoDS_Compound, TopoDS_CompSolid, topods_Edge,
+                             topods_Vertex, TopoDS_Iterator)
+from OCC.GCPnts import GCPnts_UniformAbscissa
+from OCC.BRepAdaptor import BRepAdaptor_Curve
+
+class WireExplorer(object):
+    '''
+    Wire traversal
+    '''
+    def __init__(self, wire):
+        if not isinstance(wire, TopoDS_Wire):
+            raise AssertionError('not a TopoDS_Wire')
+        self.wire = wire
+        self.wire_explorer = BRepTools_WireExplorer(self.wire)
+        self.done = False
+
+    def _reinitialize(self):
+        self.wire_explorer = BRepTools_WireExplorer(self.wire)
+        self.done = False
+
+    def _loop_topo(self, edges=True):
+        if self.done:
+            self._reinitialize()
+        topologyType = topods_Edge if edges else topods_Vertex
+        seq = []
+        hashes = []  # list that stores hashes to avoid redundancy
+        occ_seq = TopTools_ListOfShape()
+        while self.wire_explorer.More():
+            # loop edges
+            if edges:
+                current_item = self.wire_explorer.Current()
+            # loop vertices
+            else:
+                current_item = self.wire_explorer.CurrentVertex()
+            current_item_hash = current_item.__hash__()
+            if not current_item_hash in hashes:
+                hashes.append(current_item_hash)
+                occ_seq.Append(current_item)
+            self.wire_explorer.Next()
+
+        # Convert occ_seq to python list
+        occ_iterator = TopTools_ListIteratorOfListOfShape(occ_seq)
+        while occ_iterator.More():
+            topo_to_add = topologyType(occ_iterator.Value())
+            seq.append(topo_to_add)
+            occ_iterator.Next()
+        self.done = True
+        return iter(seq)
+
+    def ordered_edges(self):
+        return self._loop_topo(edges=True)
+
+    def ordered_vertices(self):
+        return self._loop_topo(edges=False)
+
+
+class TopologyExplorer(object):
+    '''
+    Topology traversal
+    '''
+
+    def __init__(self, myShape, ignore_orientation=False):
+        """
+
+        implements topology traversal from any TopoDS_Shape
+        this class lets you find how various topological entities are connected from one to another
+        find the faces connected to an edge, find the vertices this edge is made from, get all faces connected to
+        a vertex, and find out how many topological elements are connected from a source
+
+        *note* when traversing TopoDS_Wire entities, its advised to use the specialized
+        ``WireExplorer`` class, which will return the vertices / edges in the expected order
+
+        :param myShape: the shape which topology will be traversed
+
+        :param ignore_orientation: filter out TopoDS_* entities of similar TShape but different Orientation
+
+        for instance, a cube has 24 edges, 4 edges for each of 6 faces
+
+        that results in 48 vertices, while there are only 8 vertices that have a unique
+        geometric coordinate
+
+        in certain cases ( computing a graph from the topology ) its preferable to return
+        topological entities that share similar geometry, though differ in orientation
+        by setting the ``ignore_orientation`` variable
+        to True, in case of a cube, just 12 edges and only 8 vertices will be returned
+
+        for further reference see TopoDS_Shape IsEqual / IsSame methods
+
+        """
+        self.myShape = myShape
+        self.ignore_orientation = ignore_orientation
+        self.topExp = TopExp_Explorer()
+
+    def _loop_topo(self, topologyType, topologicalEntity=None, topologyTypeToAvoid=None):
+        '''
+        this could be a faces generator for a python TopoShape class
+        that way you can just do:
+        for face in srf.faces:
+            processFace(face)
+        '''
+        topoTypes = {TopAbs_VERTEX: TopoDS_Vertex,
+                     TopAbs_EDGE: TopoDS_Edge,
+                     TopAbs_FACE: TopoDS_Face,
+                     TopAbs_WIRE: TopoDS_Wire,
+                     TopAbs_SHELL: TopoDS_Shell,
+                     TopAbs_SOLID: TopoDS_Solid,
+                     TopAbs_COMPOUND: TopoDS_Compound,
+                     TopAbs_COMPSOLID: TopoDS_CompSolid}
+
+        if not topologyType in topoTypes.keys():
+            raise AssertionError('%s not one of %s' % (topologyType, topoTypes.keys()))
+        # use self.myShape if nothing is specified
+        if topologicalEntity is None and topologyTypeToAvoid is None:
+            self.topExp.Init(self.myShape, topologyType)
+        elif topologicalEntity is None and topologyTypeToAvoid is not None:
+            self.topExp.Init(self.myShape, topologyType, topologyTypeToAvoid)
+        elif topologyTypeToAvoid is None:
+            self.topExp.Init(topologicalEntity, topologyType)
+        elif topologyTypeToAvoid:
+            self.topExp.Init(topologicalEntity,
+                             topologyType,
+                             topologyTypeToAvoid)
+        seq = []
+        hashes = []  # list that stores hashes to avoid redundancy
+        occ_seq = TopTools_ListOfShape()
+        while self.topExp.More():
+            current_item = self.topExp.Current()
+            current_item_hash = current_item.__hash__()
+
+            if not current_item_hash in hashes:
+                hashes.append(current_item_hash)
+                occ_seq.Append(current_item)
+
+            self.topExp.Next()
+        # Convert occ_seq to python list
+        occ_iterator = TopTools_ListIteratorOfListOfShape(occ_seq)
+        while occ_iterator.More():
+            seq.append(occ_iterator.Value())
+            occ_iterator.Next()
+
+        if self.ignore_orientation:
+            # filter out those entities that share the same TShape
+            # but do *not* share the same orientation
+            filter_orientation_seq = []
+            for i in seq:
+                _present = False
+                for j in filter_orientation_seq:
+                    if i.IsSame(j):
+                        _present = True
+                        break
+                if _present is False:
+                    filter_orientation_seq.append(i)
+            return filter_orientation_seq
+        else:
+            return iter(seq)
+
+    def faces(self):
+        '''
+        loops over all faces
+        '''
+        return self._loop_topo(TopAbs_FACE)
+
+    def _number_of_topo(self, iterable):
+        return sum(1 for _ in iterable)
+
+    def number_of_faces(self):
+        return self._number_of_topo(self.faces())
+
+    def vertices(self):
+        '''
+        loops over all vertices
+        '''
+        return self._loop_topo(TopAbs_VERTEX)
+
+    def number_of_vertices(self):
+        return self._number_of_topo(self.vertices())
+
+    def edges(self):
+        '''
+        loops over all edges
+        '''
+        return self._loop_topo(TopAbs_EDGE)
+
+    def number_of_edges(self):
+        return self._number_of_topo(self.edges())
+
+    def wires(self):
+        '''
+        loops over all wires
+        '''
+        return self._loop_topo(TopAbs_WIRE)
+
+    def number_of_wires(self):
+        return self._number_of_topo(self.wires())
+
+    def shells(self):
+        '''
+        loops over all shells
+        '''
+        return self._loop_topo(TopAbs_SHELL, None)
+
+    def number_of_shells(self):
+        return self._number_of_topo(self.shells())
+
+    def solids(self):
+        '''
+        loops over all solids
+        '''
+        return self._loop_topo(TopAbs_SOLID, None)
+
+    def number_of_solids(self):
+        return self._number_of_topo(self.solids())
+
+    def comp_solids(self):
+        '''
+        loops over all compound solids
+        '''
+        return self._loop_topo(TopAbs_COMPSOLID)
+
+    def number_of_comp_solids(self):
+        return self._number_of_topo(self.comp_solids())
+
+    def compounds(self):
+        '''
+        loops over all compounds
+        '''
+        return self._loop_topo(TopAbs_COMPOUND)
+
+    def number_of_compounds(self):
+        return self._number_of_topo(self.compounds())
+
+    def ordered_vertices_from_wire(self, wire):
+        '''
+        @param wire: TopoDS_Wire
+        '''
+        we = WireExplorer(wire)
+        return we.ordered_vertices()
+
+    def number_of_ordered_vertices_from_wire(self, wire):
+        return self._number_of_topo(self.ordered_vertices_from_wire(wire))
+
+    def ordered_edges_from_wire(self, wire):
+        '''
+        @param wire: TopoDS_Wire
+        '''
+        we = WireExplorer(wire)
+        return we.ordered_edges()
+
+    def number_of_ordered_edges_from_wire(self, wire):
+        return self._number_of_topo(self.ordered_edges_from_wire(wire))
+
+    def _map_shapes_and_ancestors(self, topoTypeA, topoTypeB, topologicalEntity):
+        '''
+        using the same method
+        @param topoTypeA:
+        @param topoTypeB:
+        @param topologicalEntity:
+        '''
+        topo_set = set()
+        _map = TopTools_IndexedDataMapOfShapeListOfShape()
+        topexp_MapShapesAndAncestors(self.myShape, topoTypeA, topoTypeB, _map)
+        results = _map.FindFromKey(topologicalEntity)
+        if results.IsEmpty():
+            yield None
+
+        topology_iterator = TopTools_ListIteratorOfListOfShape(results)
+        while topology_iterator.More():
+
+            topo_entity = topology_iterator.Value()
+
+            # return the entity if not in set
+            # to assure we're not returning entities several times
+            if not topo_entity in topo_set:
+                if self.ignore_orientation:
+                    unique = True
+                    for i in topo_set:
+                        if i.IsSame(topo_entity):
+                            unique = False
+                            break
+                    if unique:
+                        yield topo_entity
+                else:
+                    yield topo_entity
+
+            topo_set.add(topo_entity)
+            topology_iterator.Next()
+
+    def _number_shapes_ancestors(self, topoTypeA, topoTypeB, topologicalEntity):
+        '''returns the number of shape ancestors
+        If you want to know how many edges a faces has:
+        _number_shapes_ancestors(self, TopAbs_EDGE, TopAbs_FACE, edg)
+        will return the number of edges a faces has
+        @param topoTypeA:
+        @param topoTypeB:
+        @param topologicalEntity:
+        '''
+        topo_set = set()
+        _map = TopTools_IndexedDataMapOfShapeListOfShape()
+        topexp_MapShapesAndAncestors(self.myShape, topoTypeA, topoTypeB, _map)
+        results = _map.FindFromKey(topologicalEntity)
+        if results.IsEmpty():
+            return None
+        topology_iterator = TopTools_ListIteratorOfListOfShape(results)
+        while topology_iterator.More():
+            topo_set.add(topology_iterator.Value())
+            topology_iterator.Next()
+        return len(topo_set)
+
+    # ======================================================================
+    # EDGE <-> FACE
+    # ======================================================================
+    def faces_from_edge(self, edge):
+        """
+
+        :param edge:
+        :return:
+        """
+        return self._map_shapes_and_ancestors(TopAbs_EDGE, TopAbs_FACE, edge)
+
+    def number_of_faces_from_edge(self, edge):
+        """
+
+        :param edge:
+        :return:
+        """
+        return self._number_shapes_ancestors(TopAbs_EDGE, TopAbs_FACE, edge)
+
+    def edges_from_face(self, face):
+        """
+
+        :param face:
+        :return:
+        """
+        return self._loop_topo(TopAbs_EDGE, face)
+
+    def number_of_edges_from_face(self, face):
+        return sum(1 for _ in self._loop_topo(TopAbs_EDGE, face))
+
+    # ======================================================================
+    # VERTEX <-> EDGE
+    # ======================================================================
+    def vertices_from_edge(self, edg):
+        return self._loop_topo(TopAbs_VERTEX, edg)
+
+    def number_of_vertices_from_edge(self, edg):
+        return sum(1 for _ in self._loop_topo(TopAbs_VERTEX, edg))
+
+    def edges_from_vertex(self, vertex):
+        return self._map_shapes_and_ancestors(TopAbs_VERTEX, TopAbs_EDGE, vertex)
+
+    def number_of_edges_from_vertex(self, vertex):
+        return self._number_shapes_ancestors(TopAbs_VERTEX, TopAbs_EDGE, vertex)
+
+    # ======================================================================
+    # WIRE <-> EDGE
+    # ======================================================================
+    def edges_from_wire(self, wire):
+        return self._loop_topo(TopAbs_EDGE, wire)
+
+    def number_of_edges_from_wire(self, wire):
+        return sum(1 for _ in self._loop_topo(TopAbs_EDGE, wire))
+
+    def wires_from_edge(self, edg):
+        return self._map_shapes_and_ancestors(TopAbs_EDGE, TopAbs_WIRE, edg)
+
+    def wires_from_vertex(self, edg):
+        return self._map_shapes_and_ancestors(TopAbs_VERTEX, TopAbs_WIRE, edg)
+
+    def number_of_wires_from_edge(self, edg):
+        return self._number_shapes_ancestors(TopAbs_EDGE, TopAbs_WIRE, edg)
+
+    # ======================================================================
+    # WIRE <-> FACE
+    # ======================================================================
+    def wires_from_face(self, face):
+        return self._loop_topo(TopAbs_WIRE, face)
+
+    def number_of_wires_from_face(self, face):
+        return sum(1 for _ in self._loop_topo(TopAbs_WIRE, face))
+
+    def faces_from_wire(self, wire):
+        return self._map_shapes_and_ancestors(TopAbs_WIRE, TopAbs_FACE, wire)
+
+    def number_of_faces_from_wires(self, wire):
+        return self._number_shapes_ancestors(TopAbs_WIRE, TopAbs_FACE, wire)
+
+    # ======================================================================
+    # VERTEX <-> FACE
+    # ======================================================================
+    def faces_from_vertex(self, vertex):
+        return self._map_shapes_and_ancestors(TopAbs_VERTEX, TopAbs_FACE, vertex)
+
+    def number_of_faces_from_vertex(self, vertex):
+        return self._number_shapes_ancestors(TopAbs_VERTEX, TopAbs_FACE, vertex)
+
+    def vertices_from_face(self, face):
+        return self._loop_topo(TopAbs_VERTEX, face)
+
+    def number_of_vertices_from_face(self, face):
+        return sum(1 for _ in self._loop_topo(TopAbs_VERTEX, face))
+
+    # ======================================================================
+    # FACE <-> SOLID
+    # ======================================================================
+    def solids_from_face(self, face):
+        return self._map_shapes_and_ancestors(TopAbs_FACE, TopAbs_SOLID, face)
+
+    def number_of_solids_from_face(self, face):
+        return self._number_shapes_ancestors(TopAbs_FACE, TopAbs_SOLID, face)
+
+    def faces_from_solids(self, solid):
+        return self._loop_topo(TopAbs_FACE, solid)
+
+    def number_of_faces_from_solids(self, solid):
+        return sum(1 for _ in self._loop_topo(TopAbs_FACE, solid))
+
+
+def dump_topology_to_string(shape, level=0, buffer=""):
+    """
+    Reutnrs the details of an object from the top down
+    """
+    brt = BRep_Tool()
+    s = shape.ShapeType()
+    if s == TopAbs_VERTEX:
+        pnt = brt.Pnt(topods_Vertex(shape))
+        print(".." * level  + "<Vertex %i: %s %s %s>\n" % (hash(shape), pnt.X(), pnt.Y(), pnt.Z()))
+    else:
+        print(".." * level, end="")
+        print(shape)
+    it = TopoDS_Iterator(shape)
+    while it.More() and level < 5:  # LEVEL MAX
+        shp = it.Value()
+        it.Next()
+        dump_topology_to_string(shp, level + 1, buffer)
+
+#
+# Edge and wire discretizers
+#
+
+def discretize_wire(a_topods_wire, deflection=0.5):
+    """ Returns a set of points
+    """
+    if not is_wire(a_topods_wire):
+        raise AssertionError("You must provide a TopoDS_Wire to the discretize_wire function.")
+    wire_explorer = WireExplorer(a_topods_wire)
+    wire_pnts = []
+    # loop over ordered edges
+    for edg in wire_explorer.ordered_edges():
+        edg_pnts = discretize_edge(edg, deflection=deflection)
+        wire_pnts += edg_pnts
+    return wire_pnts
+
+
+def discretize_edge(a_topods_edge, deflection=0.5):
+    """ Take a TopoDS_Edge and returns a list of points
+    The more deflection is small, the more the discretization is precise,
+    i.e. the more points you get in the returned points
+    """
+    if not is_edge(a_topods_edge):
+        raise AssertionError("You must provide a TopoDS_Edge to the discretize_edge function.")
+    if a_topods_edge.IsNull():
+        print("Warning : TopoDS_Edge is null. discretize_edge will return an empty list of points.")
+        return []
+    curve_adaptator = BRepAdaptor_Curve(a_topods_edge)
+    first = curve_adaptator.FirstParameter()
+    last = curve_adaptator.LastParameter()
+
+    discretizer = GCPnts_UniformAbscissa()
+    discretizer.Initialize(curve_adaptator, deflection, first, last)
+
+    if not discretizer.IsDone():
+        raise AssertionError("Discretizer not done.")
+    if not discretizer.NbPoints() > 0:
+        raise AssertionError("Discretizer nb points not > 0.")
+
+    points = []
+    for i in range(1, discretizer.NbPoints() + 1):
+        p = curve_adaptator.Value(discretizer.Parameter(i))
+        points.append(p.Coord())
+    return points
+
+#
+# TopoDS_Shape type utils
+#
+def is_vertex(topods_shape):
+    return topods_shape.ShapeType() == TopAbs_VERTEX
+
+
+def is_solid(topods_shape):
+    return topods_shape.ShapeType() == TopAbs_SOLID
+
+
+def is_edge(topods_shape):
+    return topods_shape.ShapeType() == TopAbs_EDGE
+
+
+def is_face(topods_shape):
+    return topods_shape.ShapeType() == TopAbs_FACE
+
+
+def is_shell(topods_shape):
+    return topods_shape.ShapeType() == TopAbs_SHELL
+
+
+def is_wire(topods_shape):
+    return topods_shape.ShapeType() == TopAbs_WIRE
+
+
+def is_compound(topods_shape):
+    return topods_shape.ShapeType() == TopAbs_COMPOUND
+
+
+def is_compsolid(topods_shape):
+    return topods_shape.ShapeType() == TopAbs_COMPSOLID
diff --git src/Extend/__init__.py src/Extend/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git src/Visualization/Display3d.cpp src/Visualization/Display3d.cpp
index 147247e..3d3a8ad 100644
--- src/Visualization/Display3d.cpp
+++ src/Visualization/Display3d.cpp
@@ -21,6 +21,7 @@
 
 
 Display3d::Display3d()
+  : myIsOffscreen(false)
 {
 }
 
@@ -28,12 +29,128 @@ Display3d::~Display3d()
 {
 }
 
-static Handle(Graphic3d_GraphicDriver)& GetGraphicDriver()
+static Handle(OpenGl_GraphicDriver)& GetGraphicDriver()
 {
-  static Handle(Graphic3d_GraphicDriver) aGraphicDriver;
+  static Handle(OpenGl_GraphicDriver) aGraphicDriver;
   return aGraphicDriver;
 }
 
+//=========================================================
+// Function : WClass
+// Purpose  :
+//=========================================================
+static const Handle(MMgt_TShared)& WClass()
+{
+  static Handle(MMgt_TShared) aWindowClass;
+#ifdef WNT
+  if (aWindowClass.IsNull())
+  {
+    aWindowClass = new WNT_WClass ("PyOCC_Class", (void*)DefWindowProc,
+                                   CS_VREDRAW | CS_HREDRAW, 0, 0,
+                                   ::LoadCursor (NULL, IDC_ARROW));
+  }
+#endif
+  return aWindowClass;
+}
+
+
+Standard_Boolean Display3d::InitOffscreen(int size_x, int size_y)
+{
+  printf(" ###### 3D rendering pipe initialisation #####\n");
+  printf("Display3d class initialization starting ...\n");
+
+  myIsOffscreen = true;
+
+  // Create graphic driver
+  Handle(Aspect_DisplayConnection) aDisplayConnection = new Aspect_DisplayConnection();
+  printf("Aspect_DisplayConnection created.\n");
+  if (GetGraphicDriver().IsNull())
+  {
+    GetGraphicDriver() = new OpenGl_GraphicDriver (aDisplayConnection);
+  }
+  printf("Graphic_Driver created.\n");
+  // Create V3dViewer and V3d_View
+  myV3dViewer = new V3d_Viewer(GetGraphicDriver(), (short* const)"viewer");
+  printf("V3d_Viewer created.\n");
+  // Create AISInteractiveViewer
+  myAISContext = new AIS_InteractiveContext(myV3dViewer);
+  printf("AIS_InteractiveContext created.\n");
+  // Create view
+  myV3dView = myV3dViewer->CreateView();  
+  printf("V3d_View created\n");
+
+  SetSize(size_x, size_y);
+
+  printf("Display3d class successfully initialized.\n");
+  printf(" ########################################\n");
+  return true;
+}
+
+Standard_Boolean Display3d::IsOffscreen()
+{
+  return myIsOffscreen;
+}
+
+Standard_Boolean Display3d::SetSize(int size_x, int size_y)
+{
+  if(myIsOffscreen)
+  {
+    mySizeX = size_x;
+    mySizeY = size_y;
+
+#ifdef WNT
+      myWindow = new WNT_Window ("PythonOCC",
+                                    Handle(WNT_WClass)::DownCast (WClass()),
+                                    WS_OVERLAPPEDWINDOW,
+                                    0, 0,
+                                    size_x, size_y,
+                                    Quantity_NOC_BLACK);
+      myWindow->SetVirtual (true);
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+      myWindow = new Cocoa_Window("PythonOCC",
+                                  0, 0,
+                                  size_x, size_y);
+      printf("Cocoa window created.\n");
+      myWindow->SetVirtual (true);
+#else
+      myWindow = new Xw_Window (myAISContext->CurrentViewer()->Driver()->GetDisplayConnection(),
+                                   "PythonOCC",
+                                   0, 0,
+                                   size_x, size_y);
+      myWindow->SetVirtual (true);
+#endif
+    myV3dView->SetWindow(myWindow);
+    return true;
+  }
+  return false;
+}
+
+Standard_Boolean Display3d::GetSize(int &size_x, int &size_y)
+{
+  if(myIsOffscreen)
+  {
+    size_x = mySizeX;
+    size_y = mySizeY;
+    return true;
+  }
+  return false;
+}
+
+Standard_Boolean Display3d::GetImageData(const char* &data, size_t &size, const Graphic3d_BufferType& theBufferType)
+{
+  if(myIsOffscreen)
+  {
+    static Image_PixMap anImage;
+    if (myV3dView->ToPixMap (anImage, mySizeX, mySizeY, theBufferType))
+    {
+      data = (const char*)anImage.Data();
+      size = anImage.SizeBytes();
+      return true;
+    }
+  }
+  return false;
+}
+
 void Display3d::Init(long window_handle)
 {
   printf(" ###### 3D rendering pipe initialisation #####\n");
@@ -73,6 +190,52 @@ void Display3d::Init(long window_handle)
 	printf(" ########################################\n");
 }
 
+void Display3d::ChangeRenderingParams(int Method,
+                                      Standard_Integer RaytracingDepth,
+                                      Standard_Boolean IsShadowEnabled,
+                                      Standard_Boolean IsReflectionEnabled,
+                                      Standard_Boolean IsAntialiasingEnabled,
+                                      Standard_Boolean IsTransparentShadowEnabled,
+                                      int StereoMode,
+                                      int AnaglyphFilter,
+                                      Standard_Boolean ToReverseStereo)
+{
+  Graphic3d_RenderingParams& aParams = myV3dView->ChangeRenderingParams();
+  aParams.Method = (Graphic3d_RenderingMode)Method;
+  aParams.RaytracingDepth = RaytracingDepth;
+  aParams.IsShadowEnabled = IsShadowEnabled;
+  aParams.IsAntialiasingEnabled = IsAntialiasingEnabled;
+  aParams.IsReflectionEnabled = IsReflectionEnabled;
+  aParams.IsTransparentShadowEnabled = IsTransparentShadowEnabled;
+  //aParams.StereoMode = (Graphic3d_StereoMode)StereoMode;
+  //aParams.AnaglyphFilter = (Graphic3d_RenderingParams::Anaglyph)AnaglyphFilter;
+  //aParams.ToReverseStereo =ToReverseStereo;
+  myV3dView->Redraw();
+}
+
+void Display3d::SetAnaglyphMode(int mode)
+{
+ /* Handle(Graphic3d_Camera) aCamera = myV3dView->Camera();
+  Graphic3d_RenderingParams* aParams = &myV3dView->ChangeRenderingParams();
+  
+  aParams->StereoMode = Graphic3d_StereoMode_Anaglyph;
+  aParams->AnaglyphFilter = (Graphic3d_RenderingParams::Anaglyph)mode;
+
+  GetGraphicDriver()->ChangeOptions().contextStereo = true;
+  aCamera->SetProjectionType (Graphic3d_Camera::Projection_Stereo);
+  myV3dView->Redraw();*/
+}
+
+void Display3d::EnableVBO()
+{
+  GetGraphicDriver()->ChangeOptions().vboDisable = false;
+}
+
+void Display3d::DisableVBO()
+{
+  GetGraphicDriver()->ChangeOptions().vboDisable = true;
+}
+
 void Display3d::Test()
 {
       BRepPrimAPI_MakeBox S(100,50,40);
diff --git src/Visualization/Tesselator.cpp src/Visualization/Tesselator.cpp
index dd99323..3e1606a 100644
--- src/Visualization/Tesselator.cpp
+++ src/Visualization/Tesselator.cpp
@@ -74,6 +74,7 @@ Tesselator::Tesselator(TopoDS_Shape   aShape,
     locVertexcoord = NULL;
     locNormalcoord = NULL;
     locTexcoord    = NULL;
+    loc_tri_indexes = NULL;
     ComputeDefaultDeviation();
 }
 
@@ -95,16 +96,17 @@ Tesselator::Tesselator(TopoDS_Shape   aShape) :
     locVertexcoord = NULL;
     locNormalcoord = NULL;
     locTexcoord    = NULL;
+    loc_tri_indexes = NULL;
     ComputeDefaultDeviation();
 }
 
-void Tesselator::Compute(bool uv_coords, bool compute_edges, float mesh_quality)
+void Tesselator::Compute(bool uv_coords, bool compute_edges, float mesh_quality, bool parallel)
 {
   if (uv_coords) {
-    TesselateWithUVCoords(compute_edges, mesh_quality);
+    TesselateWithUVCoords(compute_edges, mesh_quality, parallel);
   }
   else {
-    Tesselate(compute_edges, mesh_quality);
+    Tesselate(compute_edges, mesh_quality, parallel);
   }
 }
 
@@ -141,7 +143,7 @@ void Tesselator::SetDeviation(Standard_Real aDeviation)
 
 
 //---------------------------------------------------------------------------
-void Tesselator::Tesselate(bool compute_edges, float mesh_quality)
+void Tesselator::Tesselate(bool compute_edges, float mesh_quality, bool parallel)
 {
     TopExp_Explorer       ExpFace;
     StdPrs_ToolShadedShape   SST;
@@ -153,7 +155,7 @@ void Tesselator::Tesselate(bool compute_edges, float mesh_quality)
     gp_Pnt2d d_coord;
 
     //Triangulate
-    BRepMesh_IncrementalMesh(myShape, myDeviation*mesh_quality, false, 0.5*mesh_quality, false);
+    BRepMesh_IncrementalMesh(myShape, myDeviation*mesh_quality, false, 0.5*mesh_quality, parallel);
 
 
     for (ExpFace.Init(myShape, TopAbs_FACE); ExpFace.More(); ExpFace.Next()) {
@@ -226,7 +228,7 @@ void Tesselator::Tesselate(bool compute_edges, float mesh_quality)
 }
 
 //---------------------------------------------------------------------------
-void Tesselator::TesselateWithUVCoords(bool compute_edges, float mesh_quality)
+void Tesselator::TesselateWithUVCoords(bool compute_edges, float mesh_quality, bool parallel)
 {
   Standard_Real Umin;
   Standard_Real Umax;
@@ -246,7 +248,7 @@ void Tesselator::TesselateWithUVCoords(bool compute_edges, float mesh_quality)
   gp_Pnt2d d_coord;
   
   //Triangulate
-  BRepMesh_IncrementalMesh(myShape, myDeviation*mesh_quality, false, 0.5*mesh_quality, false);
+  BRepMesh_IncrementalMesh(myShape, myDeviation*mesh_quality, false, 0.5*mesh_quality, parallel);
 
   for (ExpFace.Init(myShape, TopAbs_FACE); ExpFace.More(); ExpFace.Next()) {
     const TopoDS_Face&    myFace    = TopoDS::Face(ExpFace.Current());
@@ -445,20 +447,72 @@ void Tesselator::ComputeEdges()
 std::string formatFloatNumber(float f) 
 {
   // returns string representation of the float number f.
-  // set precision to 4 digits
   // set epsilon to 1e-3
   float epsilon = 1e-3;
   std::stringstream formatted_float;
   if (std::abs(f) < epsilon) {
     f = 0.;
   }
-  formatted_float << std::setprecision(4) << f;
-  // 4 is perfect for the default quality
-  // for lower quality, it can be down to 3 or 2
-  // for better quality, up to 5 or 6
+  formatted_float << f;
   return formatted_float.str();
 }
 
+std::vector<float> Tesselator::GetVerticesPositionAsTuple()
+{
+  // create the vector and allocate memory
+  std::vector<float> vertices_position;
+  vertices_position.reserve(tot_triangle_count);
+  // loop over tertices
+  int pID = 0;
+  int qID = 0;
+  int rID = 0;
+  for (int i=0;i<tot_triangle_count;i++) {
+      pID = loc_tri_indexes[(i * 3) + 0] * 3;
+      vertices_position.push_back(locVertexcoord[pID]);
+      vertices_position.push_back(locVertexcoord[pID+1]);
+      vertices_position.push_back(locVertexcoord[pID+2]);
+      // Second vertex
+      qID = loc_tri_indexes[(i * 3) + 1] * 3;
+      vertices_position.push_back(locVertexcoord[qID]);
+      vertices_position.push_back(locVertexcoord[qID+1]);
+      vertices_position.push_back(locVertexcoord[qID+2]);
+      // Third vertex
+      rID = loc_tri_indexes[(i * 3) + 2] * 3;
+      vertices_position.push_back(locVertexcoord[rID]);
+      vertices_position.push_back(locVertexcoord[rID+1]);
+      vertices_position.push_back(locVertexcoord[rID+2]);
+    }
+  return vertices_position;
+}
+
+std::vector<float> Tesselator::GetNormalsAsTuple()
+{
+  // create the vector and allocate memory
+  std::vector<float> normals;
+  normals.reserve(tot_triangle_count);
+  // loop over normals
+  int pID = 0;
+  int qID = 0;
+  int rID = 0;
+  for (int i=0;i<tot_triangle_count;i++) {
+      pID = loc_tri_indexes[(i * 3) + 0] * 3;
+      normals.push_back(locNormalcoord[pID]);
+      normals.push_back(locNormalcoord[pID+1]);
+      normals.push_back(locNormalcoord[pID+2]);
+      // Second normal
+      qID = loc_tri_indexes[(i * 3) + 1] * 3;
+      normals.push_back(locNormalcoord[qID]);
+      normals.push_back(locNormalcoord[qID+1]);
+      normals.push_back(locNormalcoord[qID+2]);
+      // Third normal
+      rID = loc_tri_indexes[(i * 3) + 2] * 3;
+      normals.push_back(locNormalcoord[rID]);
+      normals.push_back(locNormalcoord[rID+1]);
+      normals.push_back(locNormalcoord[rID+2]);
+    }
+  return normals;
+}
+
 std::string Tesselator::ExportShapeToX3DIndexedFaceSet()
 {
   std::stringstream str_ifs, str_vertices, str_normals;
@@ -472,28 +526,28 @@ std::string Tesselator::ExportShapeToX3DIndexedFaceSet()
       // First Vertex
       str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[0]]) << " ";
       str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[0]+1]) <<" ";
-      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[0]+2]) <<"\n";
+      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[0]+2]) <<" ";
       // Second vertex
       str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[1]]) << " ";
       str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[1]+1]) << " ";
-      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[1]+2]) << "\n";
+      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[1]+2]) << " ";
       // Third vertex
       str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[2]]) << " ";
       str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[2]+1]) << " ";
-      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[2]+2]) << "\n";
+      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[2]+2]) << " ";
       // NORMALS
       // First normal
       str_normals << formatFloatNumber(locNormalcoord[normals_idx[0]]) << " ";
       str_normals << formatFloatNumber(locNormalcoord[normals_idx[0]+1]) << " ";
-      str_normals << formatFloatNumber(locNormalcoord[normals_idx[0]+2]) << "\n";
+      str_normals << formatFloatNumber(locNormalcoord[normals_idx[0]+2]) << " ";
       // Second normal
       str_normals << formatFloatNumber(locNormalcoord[normals_idx[1]]) << " ";
       str_normals << formatFloatNumber(locNormalcoord[normals_idx[1]+1]) << " ";
-      str_normals << formatFloatNumber(locNormalcoord[normals_idx[1]+2]) << "\n";
+      str_normals << formatFloatNumber(locNormalcoord[normals_idx[1]+2]) << " ";
       // Third normal
       str_normals << formatFloatNumber(locNormalcoord[normals_idx[2]]) << " ";
       str_normals << formatFloatNumber(locNormalcoord[normals_idx[2]+1]) << " ";
-      str_normals << formatFloatNumber(locNormalcoord[normals_idx[2]+2]) << "\n";
+      str_normals << formatFloatNumber(locNormalcoord[normals_idx[2]+2]) << " ";
   }
   str_ifs << "<TriangleSet solid='false'>\n";
   // write points coordinates
@@ -525,11 +579,11 @@ void Tesselator::ExportShapeToX3D(char * filename, int diffR, int diffG, int dif
     X3Dfile << "<Head>";
     X3Dfile << "<meta name='generator' content='pythonOCC, http://www.pythonocc.org'/>";
     X3Dfile << "</Head>";
-    X3Dfile << "<Scene><Shape><Appearance><Material DEF='Shape_Mat' diffuseColor='0.65 0.65 0.65' ";
-    X3Dfile << "shininess='0.9' specularColor='1 1 1'></Material></Appearance>";
+    X3Dfile << "<Scene><Transform scale='1 1 1'><Shape><Appearance><Material DEF='Shape_Mat' diffuseColor='0.65 0.65 0.7' ";
+    X3Dfile << "specularColor='0.2 0.2 0.2'></Material></Appearance>";
     // write tesselation
     X3Dfile << ExportShapeToX3DIndexedFaceSet();
-    X3Dfile << "</Shape></Scene></X3D>\n";
+    X3Dfile << "</Shape></Transform></Scene></X3D>\n";
     X3Dfile.close();
 
 }
diff --git src/Visualization/Tesselator.h src/Visualization/Tesselator.h
index 8185266..4685072 100644
--- src/Visualization/Tesselator.h
+++ src/Visualization/Tesselator.h
@@ -96,9 +96,9 @@ class Tesselator
                Standard_Real aRotationAngle);
       Tesselator(TopoDS_Shape aShape);
       ~Tesselator();
-      void Compute(bool uv_coords=true, bool compute_edges=false, float mesh_quality=1.0);
-      void Tesselate(bool compute_edges, float mesh_quality);
-      void TesselateWithUVCoords(bool compute_edges, float mesh_quality);
+      void Compute(bool uv_coords=true, bool compute_edges=false, float mesh_quality=1.0, bool parallel=false);
+      void Tesselate(bool compute_edges, float mesh_quality, bool parallel);
+      void TesselateWithUVCoords(bool compute_edges, float mesh_quality, bool parallel);
       void JoinPrimitives();
       void JoinPrimitivesWithUVCoords();
       void SetDeviation(Standard_Real aDeviation);
@@ -119,5 +119,7 @@ class Tesselator
       int ObjGetEdgeCount();
       int ObjEdgeGetVertexCount(int iEdge);
       void ObjGetTriangle(int trianglenum, int *vertices, int *texcoords, int *normals);
+      std::vector<float> GetVerticesPositionAsTuple();
+      std::vector<float> GetNormalsAsTuple();
 };
 #endif
diff --git src/Visualization/Visualization.h src/Visualization/Visualization.h
index bc2576e..570a03e 100644
--- src/Visualization/Visualization.h
+++ src/Visualization/Visualization.h
@@ -20,21 +20,32 @@
 #if !defined __OCC3d_Renderer__
 #define __OCC3d_Renderer__
 
+#ifdef WNT
+  #include <windows.h>
+  #include <WNT_WClass.hxx>
+  #include <WNT_Window.hxx>
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+  #include <Cocoa_Window.hxx>
+#endif
+
 #include <AIS_InteractiveContext.hxx>
 #include <BRepPrimAPI_MakeBox.hxx>
 #include <V3d_Viewer.hxx>
 #include <V3d_View.hxx>
 #include <AIS_Shape.hxx>
 #include <Handle_Graphic3d_GraphicDriver.hxx>
+#include <Graphic3d_Camera.hxx>
+#include <Graphic3d_RenderingParams.hxx>
+#include <Graphic3d_RenderingMode.hxx>
+#include <Graphic3d_Mat4.hxx>
+#include <Graphic3d_Vec4.hxx>
 #include <OpenGl_GraphicDriver.hxx>
 #include <Aspect_DisplayConnection.hxx>
 
 #include <cstdlib>
   
 #ifdef WNT
-  #include <WNT_Window.hxx>
 #elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
-  #include <Cocoa_Window.hxx>
 #else
   #include <Xw_Window.hxx>
 #endif
@@ -45,15 +56,38 @@ public:
 	Standard_EXPORT Display3d();
 	Standard_EXPORT virtual ~Display3d();
 	Standard_EXPORT void Init(long window_handle);
-	Standard_EXPORT Handle_V3d_View& GetView() {return myV3dView;};
+  Standard_EXPORT void SetAnaglyphMode(int mode);
+  Standard_EXPORT void ChangeRenderingParams(int Method,
+                                             Standard_Integer        RaytracingDepth,
+                                             Standard_Boolean        IsShadowEnabled,
+                                             Standard_Boolean        IsReflectionEnabled,
+                                             Standard_Boolean        IsAntialiasingEnabled,
+                                             Standard_Boolean        IsTransparentShadowEnabled,
+                                             int    StereoMode,
+                                             int AnaglyphFilter,
+                                             Standard_Boolean        ToReverseStereo);
+  Standard_EXPORT void EnableVBO();
+  Standard_EXPORT void DisableVBO();
+  Standard_EXPORT Handle_V3d_View& GetView() {return myV3dView;};
 	Standard_EXPORT Handle_V3d_Viewer& GetViewer() {return myV3dViewer;};
 	Standard_EXPORT Handle_AIS_InteractiveContext GetContext() {return myAISContext;};
 	Standard_EXPORT void Test();
-    
+
+  Standard_EXPORT bool IsOffscreen();
+  Standard_EXPORT bool InitOffscreen(int size_x, int size_y);
+  Standard_EXPORT bool SetSize(int size_x, int size_y);
+  Standard_EXPORT bool GetSize(int &size_x, int &size_y);
+  Standard_EXPORT bool GetImageData(const char* &data, size_t &size, const Graphic3d_BufferType& theBufferType = Graphic3d_BT_RGB);
+
 protected:
    Handle_AIS_InteractiveContext myAISContext;
    Handle_V3d_Viewer myV3dViewer;
    Handle_V3d_View myV3dView;
+
+   int mySizeX;
+   int mySizeY;
+   bool myIsOffscreen;
+
    #ifdef WNT
      Handle_WNT_Window myWindow;
    #elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
diff --git src/Visualization/Visualization.i src/Visualization/Visualization.i
index 366a6e2..147b3ea 100644
--- src/Visualization/Visualization.i
+++ src/Visualization/Visualization.i
@@ -26,8 +26,11 @@
 
 %include ../SWIG_files/common/ExceptionCatcher.i
 %include "python/std_string.i"
+%include "std_vector.i"
 %include "typemaps.i"
 
+%template(vector_float) std::vector<float>;
+
 %typemap(out) float [ANY] {
   int i;
   $result = PyList_New($1_dim0);
@@ -38,16 +41,17 @@
 }
 
 enum theTextureMappingRule {
-	atCube,
-	atNormal,
-	atNormalAutoScale
-	};
+  atCube,
+  atNormal,
+  atNormalAutoScale
+  };
 
 %apply int& OUTPUT {int& v1, int& v2, int& v3}
 %apply float& OUTPUT {float& x, float& y, float& z}
 
 class Tesselator {
  public:
+    %feature("autodoc", "1");
     Tesselator(TopoDS_Shape aShape,
                theTextureMappingRule aTxtMapType,
                float anAutoScaleSizeOnU,
@@ -60,40 +64,92 @@ class Tesselator {
                float aScaleU,
                float aScaleV,
                float aRotationAngle);
+    %feature("autodoc", "1");
     Tesselator(TopoDS_Shape aShape);
+    %feature("autodoc", "1");
+    ~Tesselator();
     %feature("kwargs") Compute;
-    void Compute(bool uv_coords=true, bool compute_edges=false, float mesh_quality=1.0);
+    void Compute(bool uv_coords=true, bool compute_edges=false, float mesh_quality=1.0, bool parallel=false);
     void GetVertex(int ivert, float& x, float& y, float& z);
     void GetNormal(int inorm, float& x, float& y, float& z);
     void GetTriangleIndex(int triangleIdx, int& v1, int& v2, int& v3);
     void GetEdgeVertex(int iEdge, int ivert, float& x, float& y, float& z);
-	float* VerticesList();
-	int ObjGetTriangleCount();
-	int ObjGetVertexCount();
-	int ObjGetNormalCount();
-	int ObjGetEdgeCount();
-	int ObjEdgeGetVertexCount(int iEdge);
+    float* VerticesList();
+    int ObjGetTriangleCount();
+    int ObjGetVertexCount();
+    int ObjGetNormalCount();
+    int ObjGetEdgeCount();
+    int ObjEdgeGetVertexCount(int iEdge);
     std::string ExportShapeToX3DIndexedFaceSet();
-	std::string ExportShapeToThreejsJSONString(char *shape_function_name, bool export_uv=false);
-	%feature("kwargs") ExportShapeToX3D;
-	void ExportShapeToX3D(char *filename, int diffR=1, int diffG=0, int diffB=0);
+    std::string ExportShapeToThreejsJSONString(char *shape_function_name, bool export_uv=false);
+    %feature("kwargs") ExportShapeToX3D;
+    void ExportShapeToX3D(char *filename, int diffR=1, int diffG=0, int diffB=0);
+    std::vector<float> GetVerticesPositionAsTuple();
+    std::vector<float> GetNormalsAsTuple();
 };
 
 class Display3d {
  public:
-	%feature("autodoc", "1");
-	Display3d();
-	%feature("autodoc", "1");
-	~Display3d();
-	%feature("autodoc", "1");
-	void Init(const long handle);
-	%feature("autodoc", "1");
-	Handle_V3d_View& GetView();
-	%feature("autodoc", "1");
-	Handle_V3d_Viewer& GetViewer();
-	%feature("autodoc", "1");
-	Handle_AIS_InteractiveContext GetContext();
-	%feature("autodoc", "1");
-	void Test();
+    %feature("autodoc", "1");
+    Display3d();
+    %feature("autodoc", "1");
+    ~Display3d();
+    %feature("autodoc", "1");
+    void Init(const long handle);
+    %feature("autodoc", "1");
+    void SetAnaglyphMode(int mode);
+    %feature("autodoc", "1");
+    void ChangeRenderingParams(int  Method,
+                               int  RaytracingDepth,
+                               bool IsShadowEnabled,
+                               bool IsReflectionEnabled,
+                               bool IsAntialiasingEnabled,
+                               bool IsTransparentShadowEnabled,
+                               int  StereoMode,
+                               int  AnaglyphFilter,
+                               bool ToReverseStere);
+    %feature("autodoc", "1");
+    void EnableVBO();
+    %feature("autodoc", "1");
+    void DisableVBO();
+    %feature("autodoc", "1");
+    Handle_V3d_View& GetView();
+    %feature("autodoc", "1");
+    Handle_V3d_Viewer& GetViewer();
+    %feature("autodoc", "1");
+    Handle_AIS_InteractiveContext GetContext();
+    %feature("autodoc", "1");
+    void Test();
+
+    %feature("autodoc", "1");
+    bool InitOffscreen(int size_x, int size_y);
+    %feature("autodoc", "1");
+    bool SetSize(int size_x, int size_y);
+    %feature("autodoc", "1");
+    bool IsOffscreen();
+};
+
+%extend Display3d {
+    PyObject* GetImageData(int bufType = 0) {
+        const char * data;
+        size_t size = 0;
+        Graphic3d_BufferType theBufferType = (Graphic3d_BufferType)bufType;
+
+        if ($self->GetImageData(data, size, theBufferType)) {
+            return PyBytes_FromStringAndSize(data, (Py_ssize_t)size);
+        }
+        Py_RETURN_NONE;
+    }
+
+    PyObject* GetSize() {
+        int size_x;
+        int size_y;
+
+        if ($self->GetSize(size_x, size_y)) {
+            return Py_BuildValue("ii", size_x, size_y);
+        }
+        Py_RETURN_NONE;
+    }
+
 };
 
-- 
2.21.0.windows.1

