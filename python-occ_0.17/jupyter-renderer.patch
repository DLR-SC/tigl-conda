diff --git CMakeLists.txt CMakeLists.txt
index 6aa54c6..0a1c0cd 100644
--- CMakeLists.txt
+++ CMakeLists.txt
@@ -310,6 +310,8 @@ endif(PYTHONOCC_WRAP_VISU)
 
 # install addons
 install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/src/addons/Display DESTINATION ${PYTHONOCC_INSTALL_DIRECTORY} )
+install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/src/Extend DESTINATION ${PYTHONOCC_INSTALL_DIRECTORY} )
+
 # install LICENSE file
 install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/LICENSE DESTINATION ${PYTHONOCC_INSTALL_DIRECTORY} )
 # install AUTHORS file
diff --git src/Extend/TopologyUtils.py src/Extend/TopologyUtils.py
new file mode 100644
index 0000000..dc33711
--- /dev/null
+++ src/Extend/TopologyUtils.py
@@ -0,0 +1,662 @@
+#!/usr/bin/env python
+
+##Copyright 2008-2015 Jelle Feringa (jelleferinga@gmail.com)
+##
+##This file is part of pythonOCC.
+##
+##pythonOCC is free software: you can redistribute it and/or modify
+##it under the terms of the GNU Lesser General Public License as published by
+##the Free Software Foundation, either version 3 of the License, or
+##(at your option) any later version.
+##
+##pythonOCC is distributed in the hope that it will be useful,
+##but WITHOUT ANY WARRANTY; without even the implied warranty of
+##MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+##GNU Lesser General Public License for more details.
+##
+##You should have received a copy of the GNU Lesser General Public License
+##along with pythonOCC.  If not, see <http://www.gnu.org/licenses/>.
+
+from __future__ import print_function
+
+from OCC.BRepPrimAPI import BRepPrimAPI_MakeBox, BRepPrimAPI_MakeSphere
+from OCC.BRep import BRep_Tool
+from OCC.BRepTools import BRepTools_WireExplorer
+from OCC.TopAbs import (TopAbs_VERTEX, TopAbs_EDGE, TopAbs_FACE, TopAbs_WIRE,
+                        TopAbs_SHELL, TopAbs_SOLID, TopAbs_COMPOUND,
+                        TopAbs_COMPSOLID)
+from OCC.TopExp import TopExp_Explorer, topexp_MapShapesAndAncestors
+from OCC.TopTools import (TopTools_ListOfShape,
+                          TopTools_ListIteratorOfListOfShape,
+                          TopTools_IndexedDataMapOfShapeListOfShape)
+from OCC.TopoDS import (topods, TopoDS_Wire, TopoDS_Vertex, TopoDS_Edge,
+                        TopoDS_Face, TopoDS_Shell, TopoDS_Solid,
+                        TopoDS_Compound, TopoDS_CompSolid, topods_Edge,
+                        topods_Vertex, TopoDS_Iterator)
+
+
+class WireExplorer(object):
+    '''
+    Wire traversal
+    '''
+    def __init__(self, wire):
+        assert isinstance(wire, TopoDS_Wire), 'not a TopoDS_Wire'
+        self.wire = wire
+        self.wire_explorer = BRepTools_WireExplorer(self.wire)
+        self.done = False
+
+    def _reinitialize(self):
+        self.wire_explorer = BRepTools_WireExplorer(self.wire)
+        self.done = False
+
+    def _loop_topo(self, edges=True):
+        if self.done:
+            self._reinitialize()
+        topologyType = topods_Edge if edges else topods_Vertex
+        seq = []
+        hashes = []  # list that stores hashes to avoid redundancy
+        occ_seq = TopTools_ListOfShape()
+        while self.wire_explorer.More():
+            # loop edges
+            if edges:
+                current_item = self.wire_explorer.Current()
+            # loop vertices
+            else:
+                current_item = self.wire_explorer.CurrentVertex()
+            current_item_hash = current_item.__hash__()
+            if not current_item_hash in hashes:
+                hashes.append(current_item_hash)
+                occ_seq.Append(current_item)
+            self.wire_explorer.Next()
+
+        # Convert occ_seq to python list
+        occ_iterator = TopTools_ListIteratorOfListOfShape(occ_seq)
+        while occ_iterator.More():
+            topo_to_add = topologyType(occ_iterator.Value())
+            seq.append(topo_to_add)
+            occ_iterator.Next()
+        self.done = True
+        return iter(seq)
+
+    def ordered_edges(self):
+        return self._loop_topo(edges=True)
+
+    def ordered_vertices(self):
+        return self._loop_topo(edges=False)
+
+
+class TopologyExplorer(object):
+    '''
+    Topology traversal
+    '''
+
+    def __init__(self, myShape, ignore_orientation=False):
+        """
+
+        implements topology traversal from any TopoDS_Shape
+        this class lets you find how various topological entities are connected from one to another
+        find the faces connected to an edge, find the vertices this edge is made from, get all faces connected to
+        a vertex, and find out how many topological elements are connected from a source
+
+        *note* when traversing TopoDS_Wire entities, its advised to use the specialized
+        ``WireExplorer`` class, which will return the vertices / edges in the expected order
+
+        :param myShape: the shape which topology will be traversed
+
+        :param ignore_orientation: filter out TopoDS_* entities of similar TShape but different Orientation
+
+        for instance, a cube has 24 edges, 4 edges for each of 6 faces
+
+        that results in 48 vertices, while there are only 8 vertices that have a unique
+        geometric coordinate
+
+        in certain cases ( computing a graph from the topology ) its preferable to return
+        topological entities that share similar geometry, though differ in orientation
+        by setting the ``ignore_orientation`` variable
+        to True, in case of a cube, just 12 edges and only 8 vertices will be returned
+
+        for further reference see TopoDS_Shape IsEqual / IsSame methods
+
+        """
+        self.myShape = myShape
+        self.ignore_orientation = ignore_orientation
+
+        # the topoFactory dicts maps topology types and functions that can
+        # create this topology
+        self.topoFactory = {
+            TopAbs_VERTEX: topods.Vertex,
+            TopAbs_EDGE: topods.Edge,
+            TopAbs_FACE: topods.Face,
+            TopAbs_WIRE: topods.Wire,
+            TopAbs_SHELL: topods.Shell,
+            TopAbs_SOLID: topods.Solid,
+            TopAbs_COMPOUND: topods.Compound,
+            TopAbs_COMPSOLID: topods.CompSolid
+        }
+        self.topExp = TopExp_Explorer()
+
+    def _loop_topo(self, topologyType, topologicalEntity=None, topologyTypeToAvoid=None):
+        '''
+        this could be a faces generator for a python TopoShape class
+        that way you can just do:
+        for face in srf.faces:
+            processFace(face)
+        '''
+        topoTypes = {TopAbs_VERTEX: TopoDS_Vertex,
+                     TopAbs_EDGE: TopoDS_Edge,
+                     TopAbs_FACE: TopoDS_Face,
+                     TopAbs_WIRE: TopoDS_Wire,
+                     TopAbs_SHELL: TopoDS_Shell,
+                     TopAbs_SOLID: TopoDS_Solid,
+                     TopAbs_COMPOUND: TopoDS_Compound,
+                     TopAbs_COMPSOLID: TopoDS_CompSolid}
+
+        assert topologyType in topoTypes.keys(), '%s not one of %s' % (topologyType, topoTypes.keys())
+        # use self.myShape if nothing is specified
+        if topologicalEntity is None and topologyTypeToAvoid is None:
+            self.topExp.Init(self.myShape, topologyType)
+        elif topologicalEntity is None and topologyTypeToAvoid is not None:
+            self.topExp.Init(self.myShape, topologyType, topologyTypeToAvoid)
+        elif topologyTypeToAvoid is None:
+            self.topExp.Init(topologicalEntity, topologyType)
+        elif topologyTypeToAvoid:
+            self.topExp.Init(topologicalEntity,
+                             topologyType,
+                             topologyTypeToAvoid)
+        seq = []
+        hashes = []  # list that stores hashes to avoid redundancy
+        occ_seq = TopTools_ListOfShape()
+        while self.topExp.More():
+            current_item = self.topExp.Current()
+            current_item_hash = current_item.__hash__()
+
+            if not current_item_hash in hashes:
+                hashes.append(current_item_hash)
+                occ_seq.Append(current_item)
+
+            self.topExp.Next()
+        # Convert occ_seq to python list
+        occ_iterator = TopTools_ListIteratorOfListOfShape(occ_seq)
+        while occ_iterator.More():
+            topo_to_add = self.topoFactory[topologyType](occ_iterator.Value())
+            seq.append(topo_to_add)
+            occ_iterator.Next()
+
+        if self.ignore_orientation:
+            # filter out those entities that share the same TShape
+            # but do *not* share the same orientation
+            filter_orientation_seq = []
+            for i in seq:
+                _present = False
+                for j in filter_orientation_seq:
+                    if i.IsSame(j):
+                        _present = True
+                        break
+                if _present is False:
+                    filter_orientation_seq.append(i)
+            return filter_orientation_seq
+        else:
+            return iter(seq)
+
+    def faces(self):
+        '''
+        loops over all faces
+        '''
+        return self._loop_topo(TopAbs_FACE)
+
+    def _number_of_topo(self, iterable):
+        n = 0
+        for i in iterable:
+            n += 1
+        return n
+
+    def number_of_faces(self):
+        return self._number_of_topo(self.faces())
+
+    def vertices(self):
+        '''
+        loops over all vertices
+        '''
+        return self._loop_topo(TopAbs_VERTEX)
+
+    def number_of_vertices(self):
+        return self._number_of_topo(self.vertices())
+
+    def edges(self):
+        '''
+        loops over all edges
+        '''
+        return self._loop_topo(TopAbs_EDGE)
+
+    def number_of_edges(self):
+        return self._number_of_topo(self.edges())
+
+    def wires(self):
+        '''
+        loops over all wires
+        '''
+        return self._loop_topo(TopAbs_WIRE)
+
+    def number_of_wires(self):
+        return self._number_of_topo(self.wires())
+
+    def shells(self):
+        '''
+        loops over all shells
+        '''
+        return self._loop_topo(TopAbs_SHELL, None)
+
+    def number_of_shells(self):
+        return self._number_of_topo(self.shells())
+
+    def solids(self):
+        '''
+        loops over all solids
+        '''
+        return self._loop_topo(TopAbs_SOLID, None)
+
+    def number_of_solids(self):
+        return self._number_of_topo(self.solids())
+
+    def comp_solids(self):
+        '''
+        loops over all compound solids
+        '''
+        return self._loop_topo(TopAbs_COMPSOLID)
+
+    def number_of_comp_solids(self):
+        return self._number_of_topo(self.comp_solids())
+
+    def compounds(self):
+        '''
+        loops over all compounds
+        '''
+        return self._loop_topo(TopAbs_COMPOUND)
+
+    def number_of_compounds(self):
+        return self._number_of_topo(self.compounds())
+
+    def ordered_vertices_from_wire(self, wire):
+        '''
+        @param wire: TopoDS_Wire
+        '''
+        we = WireExplorer(wire)
+        return we.ordered_vertices()
+
+    def number_of_ordered_vertices_from_wire(self, wire):
+        return self._number_of_topo(self.ordered_vertices_from_wire(wire))
+
+    def ordered_edges_from_wire(self, wire):
+        '''
+        @param wire: TopoDS_Wire
+        '''
+        we = WireExplorer(wire)
+        return we.ordered_edges()
+
+    def number_of_ordered_edges_from_wire(self, wire):
+        return self._number_of_topo(self.ordered_edges_from_wire(wire))
+
+    def _map_shapes_and_ancestors(self, topoTypeA, topoTypeB, topologicalEntity):
+        '''
+        using the same method
+        @param topoTypeA:
+        @param topoTypeB:
+        @param topologicalEntity:
+        '''
+        topo_set = set()
+        _map = TopTools_IndexedDataMapOfShapeListOfShape()
+        topexp_MapShapesAndAncestors(self.myShape, topoTypeA, topoTypeB, _map)
+        results = _map.FindFromKey(topologicalEntity)
+        if results.IsEmpty():
+            yield None
+
+        topology_iterator = TopTools_ListIteratorOfListOfShape(results)
+        while topology_iterator.More():
+
+            topo_entity = self.topoFactory[topoTypeB](topology_iterator.Value())
+
+            # return the entity if not in set
+            # to assure we're not returning entities several times
+            if not topo_entity in topo_set:
+                if self.ignore_orientation:
+                    unique = True
+                    for i in topo_set:
+                        if i.IsSame(topo_entity):
+                            unique = False
+                            break
+                    if unique:
+                        yield topo_entity
+                else:
+                    yield topo_entity
+
+            topo_set.add(topo_entity)
+            topology_iterator.Next()
+
+    def _number_shapes_ancestors(self, topoTypeA, topoTypeB, topologicalEntity):
+        '''returns the number of shape ancestors
+        If you want to know how many edges a faces has:
+        _number_shapes_ancestors(self, TopAbs_EDGE, TopAbs_FACE, edg)
+        will return the number of edges a faces has
+        @param topoTypeA:
+        @param topoTypeB:
+        @param topologicalEntity:
+        '''
+        topo_set = set()
+        _map = TopTools_IndexedDataMapOfShapeListOfShape()
+        topexp_MapShapesAndAncestors(self.myShape, topoTypeA, topoTypeB, _map)
+        results = _map.FindFromKey(topologicalEntity)
+        if results.IsEmpty():
+            return None
+        topology_iterator = TopTools_ListIteratorOfListOfShape(results)
+        while topology_iterator.More():
+            topo_set.add(topology_iterator.Value())
+            topology_iterator.Next()
+        return len(topo_set)
+
+    # ======================================================================
+    # EDGE <-> FACE
+    # ======================================================================
+    def faces_from_edge(self, edge):
+        """
+
+        :param edge:
+        :return:
+        """
+        return self._map_shapes_and_ancestors(TopAbs_EDGE, TopAbs_FACE, edge)
+
+    def number_of_faces_from_edge(self, edge):
+        """
+
+        :param edge:
+        :return:
+        """
+        return self._number_shapes_ancestors(TopAbs_EDGE, TopAbs_FACE, edge)
+
+    def edges_from_face(self, face):
+        """
+
+        :param face:
+        :return:
+        """
+        return self._loop_topo(TopAbs_EDGE, face)
+
+    def number_of_edges_from_face(self, face):
+        cnt = 0
+        for i in self._loop_topo(TopAbs_EDGE, face):
+            cnt += 1
+        return cnt
+
+    # ======================================================================
+    # VERTEX <-> EDGE
+    # ======================================================================
+    def vertices_from_edge(self, edg):
+        return self._loop_topo(TopAbs_VERTEX, edg)
+
+    def number_of_vertices_from_edge(self, edg):
+        cnt = 0
+        for i in self._loop_topo(TopAbs_VERTEX, edg):
+            cnt += 1
+        return cnt
+
+    def edges_from_vertex(self, vertex):
+        return self._map_shapes_and_ancestors(TopAbs_VERTEX, TopAbs_EDGE, vertex)
+
+    def number_of_edges_from_vertex(self, vertex):
+        return self._number_shapes_ancestors(TopAbs_VERTEX, TopAbs_EDGE, vertex)
+
+    # ======================================================================
+    # WIRE <-> EDGE
+    # ======================================================================
+    def edges_from_wire(self, wire):
+        return self._loop_topo(TopAbs_EDGE, wire)
+
+    def number_of_edges_from_wire(self, wire):
+        cnt = 0
+        for i in self._loop_topo(TopAbs_EDGE, wire):
+            cnt += 1
+        return cnt
+
+    def wires_from_edge(self, edg):
+        return self._map_shapes_and_ancestors(TopAbs_EDGE, TopAbs_WIRE, edg)
+
+    def wires_from_vertex(self, edg):
+        return self._map_shapes_and_ancestors(TopAbs_VERTEX, TopAbs_WIRE, edg)
+
+    def number_of_wires_from_edge(self, edg):
+        return self._number_shapes_ancestors(TopAbs_EDGE, TopAbs_WIRE, edg)
+
+    # ======================================================================
+    # WIRE <-> FACE
+    # ======================================================================
+    def wires_from_face(self, face):
+        return self._loop_topo(TopAbs_WIRE, face)
+
+    def number_of_wires_from_face(self, face):
+        cnt = 0
+        for i in self._loop_topo(TopAbs_WIRE, face):
+            cnt += 1
+        return cnt
+
+    def faces_from_wire(self, wire):
+        return self._map_shapes_and_ancestors(TopAbs_WIRE, TopAbs_FACE, wire)
+
+    def number_of_faces_from_wires(self, wire):
+        return self._number_shapes_ancestors(TopAbs_WIRE, TopAbs_FACE, wire)
+
+    # ======================================================================
+    # VERTEX <-> FACE
+    # ======================================================================
+    def faces_from_vertex(self, vertex):
+        return self._map_shapes_and_ancestors(TopAbs_VERTEX, TopAbs_FACE, vertex)
+
+    def number_of_faces_from_vertex(self, vertex):
+        return self._number_shapes_ancestors(TopAbs_VERTEX, TopAbs_FACE, vertex)
+
+    def vertices_from_face(self, face):
+        return self._loop_topo(TopAbs_VERTEX, face)
+
+    def number_of_vertices_from_face(self, face):
+        cnt = 0
+        for i in self._loop_topo(TopAbs_VERTEX, face):
+            cnt += 1
+        return cnt
+
+    # ======================================================================
+    # FACE <-> SOLID
+    # ======================================================================
+    def solids_from_face(self, face):
+        return self._map_shapes_and_ancestors(TopAbs_FACE, TopAbs_SOLID, face)
+
+    def number_of_solids_from_face(self, face):
+        return self._number_shapes_ancestors(TopAbs_FACE, TopAbs_SOLID, face)
+
+    def faces_from_solids(self, solid):
+        return self._loop_topo(TopAbs_FACE, solid)
+
+    def number_of_faces_from_solids(self, solid):
+        cnt = 0
+        for i in self._loop_topo(TopAbs_FACE, solid):
+            cnt += 1
+        return cnt
+
+
+def dump_topology_to_string(shape, level=0, buffer=""):
+    """
+    Reutnrs the details of an object from the top down
+    """
+    brt = BRep_Tool()
+    s = shape.ShapeType()
+    if s == TopAbs_VERTEX:
+        pnt = brt.Pnt(topods_Vertex(shape))
+        print( ".." * level  + "<Vertex %i: %s %s %s>\n" % (hash(shape), pnt.X(), pnt.Y(), pnt.Z()))
+    else:
+        print(".." * level, end ="")
+        print(shape_type_string(shape))
+    it = TopoDS_Iterator(shape)
+    while it.More() and level < 5:  # LEVEL MAX
+        shp = it.Value()
+        it.Next()
+        print(dump_topology_to_string(shp, level + 1, buffer))
+
+
+def shape_type_string(shape):
+    """ Returns the type and id of any topods_shape
+    shape: a TopoDS_Shape
+    returns a tuple
+    the shape type, as a string
+    the shape id, as a string
+    """
+    shape_type = shape.ShapeType()
+    types = {TopAbs_VERTEX: "Vertex", TopAbs_SOLID: "Solid", TopAbs_EDGE: "Edge",
+             TopAbs_FACE: "Face", TopAbs_SHELL: "Shell", TopAbs_WIRE: "Wire",
+             TopAbs_COMPOUND: "Compound", TopAbs_COMPSOLID: "Compsolid"}
+    return "%s (id %s)" % (types[shape_type], hash(shape))
+
+
+def get_test_box_shape():
+    return BRepPrimAPI_MakeBox(10, 20, 30).Shape()
+
+
+def get_test_sphere_shape():
+    return BRepPrimAPI_MakeSphere(10.).Shape()
+
+
+def test_loop_faces():
+    i = 0
+    for face in topo.faces():
+        i += 1
+        assert(isinstance(face, TopoDS_Face))
+    assert i == 6
+
+
+def test_loop_edges():
+    i = 0
+    for face in topo.edges():
+        i += 1
+        assert(isinstance(face, TopoDS_Edge))
+    assert i == 12
+
+
+def number_of_topological_entities():
+    assert topo.number_of_faces() == 6
+    assert topo.number_of_edges() == 12
+    assert topo.number_of_vertices() == 8
+    assert topo.number_of_wires() == 6
+    assert topo.number_of_solids() == 1
+    assert topo.number_of_shells() == 1
+    assert topo.number_of_compounds() == 0
+    assert topo.number_of_comp_solids() == 0
+
+
+def test_nested_iteration():
+    '''check nested looping'''
+    for f in topo.faces():
+        for e in topo.edges():
+            assert isinstance(f, TopoDS_Face)
+            assert isinstance(e, TopoDS_Edge)
+
+
+def test_kept_reference():
+    '''did we keep a reference after looping several time through a list
+    of topological entities?'''
+    _tmp = []
+    _faces = [i for i in topo.faces()]
+    for f in _faces:
+        _tmp.append(f.IsNull() == 0)
+    for f in _faces:
+        _tmp.append(f.IsNull() == 0)
+    assert all(_tmp)
+
+
+def test_edge_face():
+    edg = next(topo.edges())
+    face = next(topo.faces())
+    faces_from_edge = [i for i in topo.faces_from_edge(edg)]
+    assert len(faces_from_edge) == topo.number_of_faces_from_edge(edg)
+    edges_from_face = [i for i in topo.edges_from_face(face)]
+    assert len(edges_from_face) == topo.number_of_edges_from_face(face)
+
+
+def test_edge_wire():
+    edg = next(topo.edges())
+    wire = next(topo.wires())
+    wires_from_edge = [i for i in topo.wires_from_edge(edg)]
+    assert len(wires_from_edge) == topo.number_of_wires_from_edge(edg)
+    edges_from_wire = [i for i in topo.edges_from_wire(wire)]
+    assert len(edges_from_wire) == topo.number_of_edges_from_wire(wire)
+
+
+def test_vertex_edge():
+    vert = next(topo.vertices())
+    edge = next(topo.edges())
+    verts_from_edge = [i for i in topo.vertices_from_edge(edge)]
+    assert len(verts_from_edge) == topo.number_of_vertices_from_edge(edge)
+    edges_from_vert = [i for i in topo.edges_from_vertex(vert)]
+    assert len(edges_from_vert) == topo.number_of_edges_from_vertex(vert)
+
+
+def test_vertex_face():
+    vert = next(topo.vertices())
+    face = next(topo.faces())
+    faces_from_vertex = [i for i in topo.faces_from_vertex(vert)]
+    assert len(faces_from_vertex) == topo.number_of_faces_from_vertex(vert)
+    verts_from_face = [i for i in topo.vertices_from_face(face)]
+    assert len(verts_from_face) == topo.number_of_vertices_from_face(face)
+
+
+def test_face_solid():
+    face = next(topo.faces())
+    solid = next(topo.solids())
+    faces_from_solid = [i for i in topo.faces_from_solids(solid)]
+    assert len(faces_from_solid) == topo.number_of_faces_from_solids(solid)
+    solids_from_face = [i for i in topo.solids_from_face(face)]
+    assert len(solids_from_face) == topo.number_of_solids_from_face(face)
+
+
+def test_wire_face():
+    wire = next(topo.wires())
+    face = next(topo.faces())
+    faces_from_wire = [i for i in topo.faces_from_wire(wire)]
+    assert len(faces_from_wire) == topo.number_of_faces_from_wires(wire)
+    wires_from_face = [i for i in topo.wires_from_face(face)]
+    assert len(wires_from_face) == topo.number_of_wires_from_face(face)
+
+
+def test_edges_out_of_scope():
+    # check pointers going out of scope
+    face = next(topo.faces())
+    _edges = []
+    for edg in Topo(face).edges():
+        _edges.append(edg)
+    for edg in _edges:
+        assert not edg.IsNull()
+
+
+def test_wires_out_of_scope():
+    # check pointers going out of scope
+    wire = next(topo.wires())
+    _edges, _vertices = [], []
+    for edg in WireExplorer(wire).ordered_edges():
+        _edges.append(edg)
+    for edg in _edges:
+        assert not edg.IsNull()
+    for vert in WireExplorer(wire).ordered_vertices():
+        _vertices.append(vert)
+    for v in _vertices:
+        assert not v.IsNull()
+
+if __name__ == "__main__":
+    topo = TopologyExplorer(get_test_box_shape())
+    assert topo
+    test_kept_reference()
+    test_wire_face()
+    test_face_solid()
+    test_vertex_face()
+    test_vertex_edge()
+    test_edge_wire()
+    test_edge_face()
+    test_nested_iteration()
+    test_loop_edges()
+    test_loop_faces()
+    test_edges_out_of_scope()
+    test_wires_out_of_scope()
diff --git src/Extend/__init__.py src/Extend/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git src/Visualization/Tesselator.cpp src/Visualization/Tesselator.cpp
index fc2107d..d284cea 100644
--- src/Visualization/Tesselator.cpp
+++ src/Visualization/Tesselator.cpp
@@ -19,6 +19,8 @@
 #include "Tesselator.h"
 #include <sstream>
 #include <algorithm>
+#include <cmath>
+#include <iomanip>
 //---------------------------------------------------------------------------
 #include <TopExp_Explorer.hxx>
 #include <Bnd_Box.hxx>
@@ -69,15 +71,10 @@ Tesselator::Tesselator(TopoDS_Shape   aShape,
     //prepare bbox tex coords
     PrepareBoxTextureCoordinates(myShape);
   }
-
     locVertexcoord = NULL;
     locNormalcoord = NULL;
     locTexcoord    = NULL;
-    // compute default deviation
     ComputeDefaultDeviation();
-    
-    //Tesselate();
-    TesselateWithUVCoords();
 }
 
 Tesselator::Tesselator(TopoDS_Shape   aShape) :
@@ -98,11 +95,19 @@ Tesselator::Tesselator(TopoDS_Shape   aShape) :
     locVertexcoord = NULL;
     locNormalcoord = NULL;
     locTexcoord    = NULL;
-    // compute default deviation
     ComputeDefaultDeviation();
-    
-    TesselateWithUVCoords();
 }
+
+void Tesselator::Compute(bool uv_coords, bool compute_edges, float mesh_quality, bool parallel)
+{
+  if (uv_coords) {
+    TesselateWithUVCoords(compute_edges, mesh_quality, parallel);
+  }
+  else {
+    Tesselate(compute_edges, mesh_quality, parallel);
+  }
+}
+
 //---------------------------------------------------------------------------
 Tesselator::~Tesselator()
 {
@@ -136,7 +141,7 @@ void Tesselator::SetDeviation(Standard_Real aDeviation)
 
 
 //---------------------------------------------------------------------------
-void Tesselator::Tesselate()
+void Tesselator::Tesselate(bool compute_edges, float mesh_quality, bool parallel)
 {
     TopExp_Explorer       ExpFace;
     StdPrs_ToolShadedShape   SST;
@@ -148,7 +153,8 @@ void Tesselator::Tesselate()
     gp_Pnt2d d_coord;
 
     //Triangulate
-    BRepMesh_IncrementalMesh(myShape, myDeviation);
+    BRepMesh_IncrementalMesh(myShape, myDeviation*mesh_quality, false, 0.5*mesh_quality, parallel);
+
 
     for (ExpFace.Init(myShape, TopAbs_FACE); ExpFace.More(); ExpFace.Next()) {
       const TopoDS_Face&    myFace    = TopoDS::Face(ExpFace.Current());
@@ -213,12 +219,14 @@ void Tesselator::Tesselate()
         facelist.push_back(this_face);
       }
     }
-    JoinPrimitives();    
+    JoinPrimitives();
+    if (compute_edges) {  
     ComputeEdges();
+    }
 }
 
 //---------------------------------------------------------------------------
-void Tesselator::TesselateWithUVCoords()
+void Tesselator::TesselateWithUVCoords(bool compute_edges, float mesh_quality, bool parallel)
 {
   Standard_Real Umin;
   Standard_Real Umax;
@@ -238,7 +246,7 @@ void Tesselator::TesselateWithUVCoords()
   gp_Pnt2d d_coord;
   
   //Triangulate
-  BRepMesh_IncrementalMesh(myShape, myDeviation);
+  BRepMesh_IncrementalMesh(myShape, myDeviation*mesh_quality, false, 0.5*mesh_quality, parallel);
 
   for (ExpFace.Init(myShape, TopAbs_FACE); ExpFace.More(); ExpFace.Next()) {
     const TopoDS_Face&    myFace    = TopoDS::Face(ExpFace.Current());
@@ -333,7 +341,9 @@ void Tesselator::TesselateWithUVCoords()
     }
   }
   JoinPrimitivesWithUVCoords();
-  ComputeEdges();
+  if (compute_edges) {  
+    ComputeEdges();
+  }
 }
 
 //---------------------------INTERFACE---------------------------------------
@@ -347,11 +357,11 @@ void Tesselator::ComputeDefaultDeviation()
     BRepBndLib::Add(myShape, aBox);
     aBox.Get(aXmin, aYmin, aZmin, aXmax, aYmax, aZmax);
 
-    Standard_Real xDim = abs((long)aXmax - (long)aXmin);
-    Standard_Real yDim = abs((long)aYmax - (long)aYmin);
-    Standard_Real zDim = abs((long)aZmax - (long)aZmin);
+    Standard_Real xDim = std::abs((long)aXmax - (long)aXmin);
+    Standard_Real yDim = std::abs((long)aYmax - (long)aYmin);
+    Standard_Real zDim = std::abs((long)aZmax - (long)aZmin);
 
-    Standard_Real adeviation = std::max(aXmax-aXmin, std::max(aYmax-aYmin, aZmax-aZmin)) * 1e-2 ;
+    Standard_Real adeviation = std::max(aXmax-aXmin, std::max(aYmax-aYmin, aZmax-aZmin)) * 2e-2 ;
     myDeviation = adeviation;
 }
 
@@ -431,57 +441,133 @@ void Tesselator::ComputeEdges()
   }
 }
 
+
+std::string formatFloatNumber(float f) 
+{
+  // returns string representation of the float number f.
+  // set precision to 4 digits
+  // set epsilon to 1e-3
+  float epsilon = 1e-3;
+  std::stringstream formatted_float;
+  if (std::abs(f) < epsilon) {
+    f = 0.;
+  }
+  formatted_float << std::setprecision(4) << f;
+  // 4 is perfect for the default quality
+  // for lower quality, it can be down to 3 or 2
+  // for better quality, up to 5 or 6
+  return formatted_float.str();
+}
+
+std::vector<float> Tesselator::GetVerticesPositionAsTuple()
+{
+  // create the vector and allocate memory
+  std::vector<float> vertices_position;
+  vertices_position.reserve(tot_triangle_count);
+  // loop over tertices
+  int pID = 0;
+  int qID = 0;
+  int rID = 0;
+  for (int i=0;i<tot_triangle_count;i++) {
+      pID = loc_tri_indexes[(i * 3) + 0] * 3;
+      vertices_position.push_back(locVertexcoord[pID]);
+      vertices_position.push_back(locVertexcoord[pID+1]);
+      vertices_position.push_back(locVertexcoord[pID+2]);
+      // Second vertex
+      qID = loc_tri_indexes[(i * 3) + 1] * 3;
+      vertices_position.push_back(locVertexcoord[qID]);
+      vertices_position.push_back(locVertexcoord[qID+1]);
+      vertices_position.push_back(locVertexcoord[qID+2]);
+      // Third vertex
+      rID = loc_tri_indexes[(i * 3) + 2] * 3;
+      vertices_position.push_back(locVertexcoord[rID]);
+      vertices_position.push_back(locVertexcoord[rID+1]);
+      vertices_position.push_back(locVertexcoord[rID+2]);
+    }
+  return vertices_position;
+}
+
+std::vector<float> Tesselator::GetNormalsAsTuple()
+{
+  // create the vector and allocate memory
+  std::vector<float> normals;
+  normals.reserve(tot_triangle_count);
+  // loop over normals
+  int pID = 0;
+  int qID = 0;
+  int rID = 0;
+  for (int i=0;i<tot_triangle_count;i++) {
+      pID = loc_tri_indexes[(i * 3) + 0] * 3;
+      normals.push_back(locNormalcoord[pID]);
+      normals.push_back(locNormalcoord[pID+1]);
+      normals.push_back(locNormalcoord[pID+2]);
+      // Second normal
+      qID = loc_tri_indexes[(i * 3) + 1] * 3;
+      normals.push_back(locNormalcoord[qID]);
+      normals.push_back(locNormalcoord[qID+1]);
+      normals.push_back(locNormalcoord[qID+2]);
+      // Third normal
+      rID = loc_tri_indexes[(i * 3) + 2] * 3;
+      normals.push_back(locNormalcoord[rID]);
+      normals.push_back(locNormalcoord[rID+1]);
+      normals.push_back(locNormalcoord[rID+2]);
+    }
+  return normals;
+}
+
 std::string Tesselator::ExportShapeToX3DIndexedFaceSet()
 {
-  std::stringstream str1;
+  std::stringstream str_ifs, str_vertices, str_normals;
   int *vertices_idx = new int[3];
   int *texcoords_idx = new int[3];
   int *normals_idx = new int[3];
-  
-  str1 << "<IndexedFaceSet coordIndex='";
-    for (int i=0;i<tot_triangle_count;i++) {
-        ObjGetTriangle(i, vertices_idx, texcoords_idx, normals_idx);
-        // vertex indices
-        str1 << i*3 << " " << 1+i*3 << " " << 2+i*3 << " -1\n";
-    } 
-    str1 << "' solid='false'>\n";
-    // write points coordinates
-    str1 << "<Coordinate point='";
-    for (int i=0;i<tot_triangle_count;i++) {
-        ObjGetTriangle(i, vertices_idx, texcoords_idx, normals_idx);
-        str1 <<locVertexcoord[vertices_idx[0]]<< " " <<locVertexcoord[vertices_idx[0]+1]<<" "
-            << locVertexcoord[vertices_idx[0]+2]<<"\n";
-        // Second vertex
-        str1 <<locVertexcoord[vertices_idx[1]]<<" "<<locVertexcoord[vertices_idx[1]+1]<<" "
-            << locVertexcoord[vertices_idx[1]+2]<<"\n";
-        // Third vertex
-        str1 << locVertexcoord[vertices_idx[2]]<<" "<<locVertexcoord[vertices_idx[2]+1]<<" "
-            << locVertexcoord[vertices_idx[2]+2]<<"\n";
-    }
-    str1 << "' containerField='coord'></Coordinate>\n";
-    // write normals
-    str1 << "<Normal vector='";
-    for (int i=0;i<tot_triangle_count;i++) {
-        ObjGetTriangle(i, vertices_idx, texcoords_idx, normals_idx);
-        // First normal
-        str1 << locNormalcoord[normals_idx[0]]<<" "<<locNormalcoord[normals_idx[0]+1]<<" "
-            << locNormalcoord[normals_idx[0]+2]<<"\n";
-        // Second normal
-        str1 << locNormalcoord[normals_idx[1]]<<" "<<locNormalcoord[normals_idx[1]+1]<<" "
-            << locNormalcoord[normals_idx[1]+2]<<"\n";
-        // Third normal
-        str1 << locNormalcoord[normals_idx[2]]<<" "<<locNormalcoord[normals_idx[2]+1]<<" "
-            << locNormalcoord[normals_idx[2]+2] << "\n";
-    }
-    str1 << "' containerField='normal'></Normal>\n";
-    // close all markups
-    str1 << "</IndexedFaceSet>\n";
-    
-    delete [] vertices_idx;
-    delete [] texcoords_idx;
-    delete [] normals_idx;
+  // traverse triangles and write vertices and normals strings
+  for (int i=0;i<tot_triangle_count;i++) {
+      ObjGetTriangle(i, vertices_idx, texcoords_idx, normals_idx);
+      // VERTICES
+      // First Vertex
+      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[0]]) << " ";
+      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[0]+1]) <<" ";
+      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[0]+2]) <<"\n";
+      // Second vertex
+      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[1]]) << " ";
+      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[1]+1]) << " ";
+      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[1]+2]) << "\n";
+      // Third vertex
+      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[2]]) << " ";
+      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[2]+1]) << " ";
+      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[2]+2]) << "\n";
+      // NORMALS
+      // First normal
+      str_normals << formatFloatNumber(locNormalcoord[normals_idx[0]]) << " ";
+      str_normals << formatFloatNumber(locNormalcoord[normals_idx[0]+1]) << " ";
+      str_normals << formatFloatNumber(locNormalcoord[normals_idx[0]+2]) << "\n";
+      // Second normal
+      str_normals << formatFloatNumber(locNormalcoord[normals_idx[1]]) << " ";
+      str_normals << formatFloatNumber(locNormalcoord[normals_idx[1]+1]) << " ";
+      str_normals << formatFloatNumber(locNormalcoord[normals_idx[1]+2]) << "\n";
+      // Third normal
+      str_normals << formatFloatNumber(locNormalcoord[normals_idx[2]]) << " ";
+      str_normals << formatFloatNumber(locNormalcoord[normals_idx[2]+1]) << " ";
+      str_normals << formatFloatNumber(locNormalcoord[normals_idx[2]+2]) << "\n";
+  }
+  str_ifs << "<TriangleSet solid='false'>\n";
+  // write points coordinates
+  str_ifs << "<Coordinate point='";
+  str_ifs << str_vertices.str();
+  str_ifs << "'></Coordinate>\n";
+  // write normals
+  str_ifs << "<Normal vector='";
+  str_ifs << str_normals.str();
+  str_ifs << "'></Normal>\n";
+  // close all markups
+  str_ifs << "</TriangleSet>\n";
     
-    return str1.str();
+  delete [] vertices_idx;
+  delete [] texcoords_idx;
+  delete [] normals_idx;  
+  
+  return str_ifs.str();
 }
 
 void Tesselator::ExportShapeToX3D(char * filename, int diffR, int diffG, int diffB)
@@ -504,76 +590,110 @@ void Tesselator::ExportShapeToX3D(char * filename, int diffR, int diffG, int dif
 
 }
 
-void Tesselator::ExportShapeToThreejs(char * filename)
+std::string Tesselator::ExportShapeToThreejsJSONString(char *shape_function_name, bool export_uv)
 {
-    ofstream js_file;
+    // a method that export a shape to a JSON BufferGeometry object
+    std::stringstream str_3js, str_vertices, str_normals, str_uvs;
     int *vertices_idx = new int[3];
     int *texcoords_idx = new int[3];
     int *normals_idx = new int[3];
-    js_file.open (filename);
-    // write header
-    js_file << "var Shape = function () {\n";
-    js_file << "var scope = this;\n";
-    js_file << "THREE.Geometry.call( this );\n";
-    // first write vertices coords
+    // loop over triangles and write vertices, normals and uvs if enabled
     for (int i=0;i<tot_triangle_count;i++) {
         ObjGetTriangle(i, vertices_idx, texcoords_idx, normals_idx);
+        // write vertex coordinates
         // First vertex
-        js_file << "v("<<locVertexcoord[vertices_idx[0]]<<","<<locVertexcoord[vertices_idx[0]+1]<<","
-            << locVertexcoord[vertices_idx[0]+2]<<");\n";
+        str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[0]]) << ",";
+        str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[0]+1]) << ",";
+        str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[0]+2]) << ",";
         // Second vertex
-        js_file << "v("<<locVertexcoord[vertices_idx[1]]<<","<<locVertexcoord[vertices_idx[1]+1]<<","
-            << locVertexcoord[vertices_idx[1]+2]<<");\n";
+        str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[1]]) << ",";
+        str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[1]+1]) << ",";
+        str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[1]+2]) << ",";
         // Third vertex
-        js_file << "v("<<locVertexcoord[vertices_idx[2]]<<","<<locVertexcoord[vertices_idx[2]+1]<<","
-            << locVertexcoord[vertices_idx[2]+2]<<");\n";
-        
-    
-    }
-    // write normals
-    for (int i=0;i<tot_triangle_count;i++) {
-        ObjGetTriangle(i, vertices_idx, texcoords_idx, normals_idx);
-        // vertex indices
-        js_file << "f3("<<i*3<<","<<1+i*3<<","<<2+i*3<<",";
-        // First normal
-        js_file << locNormalcoord[normals_idx[0]]<<","<<locNormalcoord[normals_idx[0]+1]<<","
-            << locNormalcoord[normals_idx[0]+2]<<",";
+        str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[2]]) << ",";
+        str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[2]+1]) << ",";
+        str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[2]+2]);
+        // Be careful, JSON parsers don't like trailing commas !!!
+        if (i != tot_triangle_count-1) {
+          str_vertices << ",";
+        }
+        // NORMALS
+          // First normal
+        str_normals << formatFloatNumber(locNormalcoord[normals_idx[0]]) << ",";
+        str_normals << formatFloatNumber(locNormalcoord[normals_idx[0]+1]) << ",";
+        str_normals << formatFloatNumber(locNormalcoord[normals_idx[0]+2]) << ",";
         // Second normal
-        js_file << locNormalcoord[normals_idx[1]]<<","<<locNormalcoord[normals_idx[1]+1]<<","
-            << locNormalcoord[normals_idx[1]+2]<<",";
+        str_normals << formatFloatNumber(locNormalcoord[normals_idx[1]]) << ",";
+        str_normals << formatFloatNumber(locNormalcoord[normals_idx[1]+1]) << ",";
+        str_normals << formatFloatNumber(locNormalcoord[normals_idx[1]+2]) << ",";
         // Third normal
-        js_file << locNormalcoord[normals_idx[2]]<<","<<locNormalcoord[normals_idx[2]+1]<<","
-            << locNormalcoord[normals_idx[2]+2];
-        js_file << ");\n";
+        str_normals << formatFloatNumber(locNormalcoord[normals_idx[2]]) << ",";
+        str_normals << formatFloatNumber(locNormalcoord[normals_idx[2]+1]) << ",";
+        str_normals << formatFloatNumber(locNormalcoord[normals_idx[2]+2]);
+        // Be careful, JSON parsers don't like trailing commas !!!
+        if (i != tot_triangle_count-1) {
+          str_normals << ",";
+        }
+        // UVs
+        if (export_uv) {
+          str_uvs << formatFloatNumber(locTexcoord[texcoords_idx[0]])<<",";
+          str_uvs << formatFloatNumber(locTexcoord[texcoords_idx[0]+2])<<",";
+          str_uvs << formatFloatNumber(locTexcoord[texcoords_idx[1]])<<",";
+          str_uvs << formatFloatNumber(locTexcoord[texcoords_idx[1]+2])<<",";
+          str_uvs << formatFloatNumber(locTexcoord[texcoords_idx[2]])<<",";
+          str_uvs << formatFloatNumber(locTexcoord[texcoords_idx[2]+2]);
+          // Be careful, JSON parsers don't like trailing commas !!!
+          if (i != tot_triangle_count-1) {
+            str_uvs <<",";
+          }
+        }
     }
-
-    // at last, write texcoords
-    for (int i=0;i<tot_triangle_count;i++) {
-        ObjGetTriangle(i, vertices_idx, texcoords_idx, normals_idx);
-        js_file << "uvs(";
-        js_file << locTexcoord[texcoords_idx[0]]<<","<<locTexcoord[texcoords_idx[0]+2]<<",";
-        js_file << locTexcoord[texcoords_idx[1]]<<","<<locTexcoord[texcoords_idx[1]+2]<<",";
-        js_file << locTexcoord[texcoords_idx[2]]<<","<<locTexcoord[texcoords_idx[2]+2];
-        js_file << ");\n";
+    str_3js << "{\n";
+    str_3js << "\t\"metadata\": {\n";
+    str_3js << "\t\t\"version\": 4.4,\n";
+    str_3js << "\t\t\"type\": \"BufferGeometry\",\n";
+    str_3js << "\t\t\"generator\": \"pythonOCC\"\n";
+    str_3js << "\t},\n";
+    str_3js << "\t\"uuid\": \"" << shape_function_name << "\",\n";
+    str_3js << "\t\"type\": \"BufferGeometry\",\n";
+    str_3js << "\t\"data\": {\n";
+    str_3js << "\t\"attributes\": {\n";
+    str_3js << "\t\t\t\"position\": {\n";
+    str_3js << "\t\t\t\t\"itemSize\": 3,\n";
+    str_3js << "\t\t\t\t\"type\": \"Float32Array\",\n";
+    str_3js << "\t\t\t\t\"array\": [";
+    // write vertices
+    str_3js << str_vertices.str();
+    str_3js << "]\n";
+    str_3js << "\t\t\t},\n";
+    str_3js << "\t\t\t\"normal\": {\n";
+    str_3js << "\t\t\t\t\"itemSize\": 3,\n";
+    str_3js << "\t\t\t\t\"type\": \"Float32Array\",\n";
+    str_3js << "\t\t\t\t\"array\": [";
+    // write normals
+    str_3js << str_normals.str();
+    str_3js << "]\n";
+    if (export_uv) {
+      str_3js << "\t\t\t},\n";
+      str_3js << "\t\t\t\"uv\": {\n";
+      str_3js << "\t\t\t\t\"itemSize\": 2,\n";
+      str_3js << "\t\t\t\t\"type\": \"Float32Array\",\n";
+      str_3js << "\t\t\t\t\"array\": [";
+      // write uvs coordinates
+      str_3js << str_uvs.str();
+      str_3js << "]\n";
     }
+    str_3js << "\t\t\t}\n";
+    // close all brackets
+    str_3js << "\t\t}\n";
+    str_3js << "\t}\n";
+    str_3js << "}\n";
 
-    // footer
-    js_file << "function v( x, y, z ) {\n";
-    js_file<< "  scope.vertices.push(new THREE.Vector3(x,y,z));\n";
-    js_file<<"}\n";
-    js_file <<"function f3( a, b, c, n1_x,n1_y,n1_z,n2_x,n2_y,n2_z,n3_x,n3_y,n3_z ) {\n";
-    js_file << "  scope.faces.push(new THREE.Face3(a,b,c,[new THREE.Vector3(n1_x,n1_y,n1_z),\n";
-    js_file << "new THREE.Vector3( n2_x, n2_y, n2_z ), new THREE.Vector3( n3_x, n3_y, n3_z ) ]  ) );\n";
-    js_file << "}\n";
-    js_file << "function uvs(a,b,c,d,e,f) {\n";
-    js_file << "scope.faceVertexUvs[ 0 ].push( [new THREE.Vector2(a,b), new THREE.Vector2(c,d), new THREE.Vector2(e,f)] );\n";
-    js_file << "}\n}\n";
-    js_file << "Shape.prototype = new THREE.Geometry();\n";
-    js_file << "Shape.prototype.constructor = Shape;\n";
-    js_file.close();
     delete [] vertices_idx;
     delete [] texcoords_idx;
     delete [] normals_idx;
+
+    return str_3js.str();
 }
 
 //---------------------------------------------------------------------------
@@ -877,9 +997,9 @@ void Tesselator::PrepareBoxTextureCoordinates(const TopoDS_Shape& aShape)
   aBox.Get(aXmin, aYmin, aZmin, aXmax, aYmax, aZmax);
 
   //enlarge the bb so all edges have the size of the biggest one
-  Standard_Real xDim = abs((long)aXmax - (long)aXmin);
-  Standard_Real yDim = abs((long)aYmax - (long)aYmin);
-  Standard_Real zDim = abs((long)aZmax - (long)aZmin);
+  Standard_Real xDim = std::abs((long)aXmax - (long)aXmin);
+  Standard_Real yDim = std::abs((long)aYmax - (long)aYmin);
+  Standard_Real zDim = std::abs((long)aZmax - (long)aZmin);
 
   if ((xDim > yDim) && (xDim > zDim)) {
     aYmin -= (xDim - yDim) / 2;
@@ -909,9 +1029,9 @@ void Tesselator::PrepareBoxTextureCoordinates(const TopoDS_Shape& aShape)
 //---------------------------------------------------------------------------
 void Tesselator::GetBoxTextureCoordinate(const gp_Pnt& p, const gp_Dir& N1, gp_Vec2d& theCoord_p)
 {
-  Standard_Real x = abs(N1.X());
-  Standard_Real y = abs(N1.Y());
-  Standard_Real z = abs(N1.Z());
+  Standard_Real x = std::abs(N1.X());
+  Standard_Real y = std::abs(N1.Y());
+  Standard_Real z = std::abs(N1.Z());
 
   if (x >= y && x >= z) {
     if (N1.X() > 0) { //right
diff --git src/Visualization/Tesselator.h src/Visualization/Tesselator.h
index 70e5af8..e008fd6 100644
--- src/Visualization/Tesselator.h
+++ src/Visualization/Tesselator.h
@@ -96,8 +96,9 @@ class Tesselator
                Standard_Real aRotationAngle);
       Tesselator(TopoDS_Shape aShape);
       ~Tesselator();
-      void Tesselate();
-      void TesselateWithUVCoords();
+      void Compute(bool uv_coords=true, bool compute_edges=false, float mesh_quality=1.0, bool parallel=false);
+      void Tesselate(bool compute_edges, float mesh_quality, bool parallel);
+      void TesselateWithUVCoords(bool compute_edges, float mesh_quality, bool parallel);
       void JoinPrimitives();
       void JoinPrimitivesWithUVCoords();
       void SetDeviation(Standard_Real aDeviation);
@@ -108,7 +109,7 @@ class Tesselator
       float* VerticesList();
       float* NormalsList();
       float* TextureCoordinatesList();
-      void ExportShapeToThreejs(char *filename);
+      std::string ExportShapeToThreejsJSONString(char *shape_function_name, bool export_uv=false);
       std::string ExportShapeToX3DIndexedFaceSet();
       void ExportShapeToX3D(char *filename, int diffR=1, int diffG=0, int diffB=0);
       int ObjGetTriangleCount();
@@ -118,5 +119,7 @@ class Tesselator
       int ObjGetEdgeCount();
       int ObjEdgeGetVertexCount(int iEdge);
       void ObjGetTriangle(int trianglenum, int *vertices, int *texcoords, int *normals);
+      std::vector<float> GetVerticesPositionAsTuple();
+      std::vector<float> GetNormalsAsTuple();
 };
 #endif
diff --git src/Visualization/Visualization.i src/Visualization/Visualization.i
index 49d32cc..3e0acd2 100644
--- src/Visualization/Visualization.i
+++ src/Visualization/Visualization.i
@@ -26,8 +26,11 @@
 
 %include ../SWIG_files/common/ExceptionCatcher.i
 %include "python/std_string.i"
+%include "std_vector.i"
 %include "typemaps.i"
 
+%template(vector_float) std::vector<float>;
+
 %typemap(out) float [ANY] {
   int i;
   $result = PyList_New($1_dim0);
@@ -48,6 +51,7 @@ enum theTextureMappingRule {
 
 class Tesselator {
  public:
+    %feature("autodoc", "1");
     Tesselator(TopoDS_Shape aShape,
                theTextureMappingRule aTxtMapType,
                float anAutoScaleSizeOnU,
@@ -60,7 +64,12 @@ class Tesselator {
                float aScaleU,
                float aScaleV,
                float aRotationAngle);
+    %feature("autodoc", "1");
     Tesselator(TopoDS_Shape aShape);
+    %feature("autodoc", "1");
+    ~Tesselator();
+    %feature("kwargs") Compute;
+    void Compute(bool uv_coords=true, bool compute_edges=false, float mesh_quality=1.0, bool parallel=false);
     void GetVertex(int ivert, float& x, float& y, float& z);
     void GetNormal(int inorm, float& x, float& y, float& z);
     void GetTriangleIndex(int triangleIdx, int& v1, int& v2, int& v3);
@@ -72,9 +81,11 @@ class Tesselator {
 	int ObjGetEdgeCount();
 	int ObjEdgeGetVertexCount(int iEdge);
     std::string ExportShapeToX3DIndexedFaceSet();
-	void ExportShapeToThreejs(char *filename);
-	void ExportShapeToX3D(char *filename, int diffR=1, int diffG=0, int diffB=0);
-	void SetDeviation(float aDeviation);
+    std::string ExportShapeToThreejsJSONString(char *shape_function_name, bool export_uv=false);
+    %feature("kwargs") ExportShapeToX3D;
+    void ExportShapeToX3D(char *filename, int diffR=1, int diffG=0, int diffB=0);
+    std::vector<float> GetVerticesPositionAsTuple();
+    std::vector<float> GetNormalsAsTuple();
 };
 
 class Display3d {
diff --git src/addons/Display/WebGl/jupyter_renderer.py src/addons/Display/WebGl/jupyter_renderer.py
new file mode 100644
index 0000000..8103b5c
--- /dev/null
+++ src/addons/Display/WebGl/jupyter_renderer.py
@@ -0,0 +1,491 @@
+##Copyright 20117-2018 Thomas Paviot (tpaviot@gmail.com)
+##
+##This file is part of pythonOCC.
+##
+##pythonOCC is free software: you can redistribute it and/or modify
+##it under the terms of the GNU Lesser General Public License as published by
+##the Free Software Foundation, either version 3 of the License, or
+##(at your option) any later version.
+##
+##pythonOCC is distributed in the hope that it will be useful,
+##but WITHOUT ANY WARRANTY; without even the implied warranty of
+##MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+##GNU Lesser General Public License for more details.
+##
+##You should have received a copy of the GNU Lesser General Public License
+##along with pythonOCC.  If not, see <http://www.gnu.org/licenses/>.
+
+from __future__ import print_function, absolute_import
+
+import sys
+import enum
+import uuid
+import operator
+from functools import reduce
+
+# pythreejs
+try:
+    from pythreejs import *
+    from IPython.display import display
+    from ipywidgets import HTML, HBox
+    import numpy as np
+except ImportError:
+    print("Error You must install pythreejs/ipywidegets/numpy to run the jupyter notebook renderer")
+    sys.exit(0)
+
+from OCC.Bnd import Bnd_Box
+from OCC.BRepBndLib import brepbndlib_Add
+from OCC.Visualization import Tesselator
+from OCC.Extend.TopologyUtils import TopologyExplorer, WireExplorer, dump_topology_to_string, shape_type_string
+
+HAVE_SMESH = False
+
+# default values
+
+def format_color(r, g, b):
+    return '#%02x%02x%02x' % (r, g, b)
+
+default_shape_color = format_color(166, 166, 166)
+default_mesh_color = 'white'
+default_edge_color = format_color(0, 0, 0)
+default_selection_material = MeshPhongMaterial(color='orange',
+                                               polygonOffset=True,
+                                               polygonOffsetFactor=1,
+                                               polygonOffsetUnits=1,
+                                               shininess=0.9)
+
+class bounding_box(object):
+    """ Representation of the bounding box of the TopoDS_Shape `shape`
+    Constructor Parameters
+    ----------
+    shape : TopoDS_Shape or a subclass such as TopoDS_Face
+        the shape to compute the bounding box from
+    tol: float
+        tolerance of the computed boundingbox
+    """
+
+    def __init__(self, shape_or_values, tol=1.e-5):
+        if isinstance(shape_or_values, tuple):
+            self.values = shape_or_values
+        else:
+            bbox = Bnd_Box()
+            bbox.SetGap(tol)
+            brepbndlib_Add(shape_or_values, bbox, True)  # use the shape triangulation
+            self.values = bbox.Get()
+
+    def __getattr__(self, k):
+        attrs_0 = "x_min", "y_min", "z_min", "x_max", "y_max", "z_max"
+        if k in attrs_0:
+            return self.values[attrs_0.index(k)]
+
+        idx = "xyz".index(k.split('_')[0])
+
+        attrs_1 = "x_size", "y_size", "z_size"
+        if k in attrs_1:
+            return self.values[idx + 3] - self.values[idx]
+
+        attrs_2 = "x_center", "y_center", "z_center"
+        if k in attrs_2:
+            return (self.values[idx] + self.values[idx + 3]) / 2.
+
+        raise AttributeError("bounding_box has no attribute " + k)
+
+    def __add__(self, other):
+        a, b = self.values, other.values
+        mi = tuple(map(min, a[0:3], b[0:3]))
+        ma = tuple(map(max, a[3:6], b[3:6]))
+        return bounding_box(mi + ma)
+
+
+class NORMAL(enum.Enum):
+    SERVER_SIDE = 1
+    CLIENT_SIDE = 2
+
+
+class JupyterRenderer(object):
+    def __init__(self, size=(480, 480), compute_normals_mode=NORMAL.SERVER_SIDE, parallel=False):
+        """ Creates a jupyter renderer.
+        size: a tuple (width, height). Must be a square, or shapes will look like deformed
+        compute_normals_mode: optional, set to SERVER_SIDE by default. This flag lets you choose the
+                              way normals are computed. If SERVER_SIDE is selected (default value), then normals
+                              will be computed by the Tesselator, packed as a python tuple, and send as a json structure
+                              to the client. If, on the other hand, CLIENT_SIDE is chose, then the computer only compute vertex
+                              indices, and let the normals be computed by the client (the web js machine embedded in the webrowser).
+                              In a few words:
+                              SERVER_SIDE: higher server load, loading time increased, lower client load. Poor performance client will
+                              choose this option (mobile terminals for instance)
+                              CLIENT_SIDE: lower server load, loading time decreased, higher client load. Higher performance clients will
+                              choose this option (laptops, desktop machines).
+        parallel: optional, False by default. If set to True, meshing runs in parallelized mode.
+        """
+        self._background = 'white'
+        self._background_opacity = 1
+        self._size = size
+        self._compute_normals_mode = compute_normals_mode
+        self._parallel = parallel
+
+        self.html = HTML("Selected shape : None")
+        # the default camera object
+        self._camera = None
+        self._camera_target = [0., 0., 0.]  # the point to look at
+        self._camera_position = [0, 0., 100.]  # the camera initial position
+
+        # a dictionnary of all the shapes belonging to the renderer
+        # each element is a key 'mesh_id:shape'
+        self._shapes = {}
+
+        # we save the renderer so that is can be accessed
+        self._renderer = None
+
+        # the group of 3d and 2d objects to render
+        self._displayed_pickable_objects = Group()
+
+        # the group of other objects (grid, trihedron etc.) that can't e selected
+        self._displayed_non_pickable_objects = Group()
+
+        # event manager/selection manager
+        self._picker = Picker(controlling=self._displayed_pickable_objects, event='mousedown')
+
+        self._current_shape_selection = None
+        self._current_mesh_selection = None
+        self._current_selection_material = None  # the color of the object currently being rendered
+        self._select_callbacks = []  # a list of all functions called after an object is selected
+
+
+        def click(value):
+            """ called whenever a shape  or edge is clicked
+            """
+            obj = value.owner.object
+            if self._current_mesh_selection is not None:
+                self._current_mesh_selection.material = self._current_selection_material
+            if obj is not None:
+                id_clicked = obj.name  # the mesh id clicked
+                self._current_mesh_selection = obj
+                self._current_selection_material = obj.material
+                obj.material = default_selection_material
+                # get the shape from this mesh id
+                selected_shape = self._shapes[id_clicked]
+                self.html.value = "<b>Shape id:</b> %s<br><b>Topology hierearchy</b>" % (selected_shape)
+                self._current_shape_selection = selected_shape
+            else:
+                self.html.value = "<b>Shape id:</b> None"
+            # then execute calbacks
+            for callback in self._select_callbacks:
+                callback(self._current_shape_selection)
+
+        self._picker.observe(click)
+
+        # key press and related events
+        def key_pressed(widget):
+            print("popo")
+        #self._picker2 = Picker(event='keypress')
+        #self._picker.observe(key_pressed)
+
+
+    def register_select_callback(self, callback):
+        """ Adds a callback that will be called each time a shape is selected
+        """
+        if not callable(callback):
+            raise AssertionError("You must provide a callable to register the callback")
+        else:
+            self._select_callbacks.append(callback)
+
+    def unregister_callback(self, callback):
+        """ Remove a callback from the callback list
+        """
+        if not callback in self._select_callbacks:
+            raise AssertionError("This callback is not registered")
+        else:
+            self._select_callbacks.remove(callback)
+
+    def _update_camera(self):
+        all_shapes = list(self._shapes.values())
+        if all_shapes:
+            bb = reduce(operator.add, map(bounding_box, all_shapes))
+            self._camera_target = [bb.x_center, bb.y_center, bb.z_center]
+            self._camera_position = [0, bb.y_center - 2 * bb.y_size, bb.z_center + 2 * bb.z_center]
+        self._camera = PerspectiveCamera(position=self._camera_position,
+                                         lookAt=self._camera_target,
+                                         up=[0, 0, 1],
+                                         aspect=self._size[0] / self._size[1],
+                                         fov=50,
+                                         children=[DirectionalLight(color='#ffffff', position=[50, 50, 50], intensity=0.9)])
+
+
+    def GetSelectedShape(self):
+        """ Returns the selected shape
+        """
+        return self._current_shape_selection
+
+
+    def DisplayGrid(self, sizex, sizey, nx, ny):
+        """ Displays a grid in the renderer.
+        sizex: float, grid size along x axis
+        sizey: float, grid size along y axis
+        nx: integer, number of segments along the x axis
+        ny: integer, number of segments along the y axis
+        """
+        surf_geo = SurfaceGeometry(z=[0] * (nx + 1) * (ny + 1),
+                                   width=sizex,
+                                   height=sizey,
+                                   width_segments=nx,
+                                   height_segments=ny)
+        surf_grid = SurfaceGrid(geometry=surf_geo,
+                                material=LineBasicMaterial(color='#000000',
+                                                           opacity=0.2,
+                                                           transparent=True))
+        self._displayed_non_pickable_objects.add(surf_grid)
+        return surf_geo
+
+
+    def DisplayMesh(self,
+                    mesh,
+                    color=default_mesh_color):
+        """ Display a MEFISTO2 triangle mesh
+        """
+        if not HAVE_SMESH:
+            print("SMESH not installed, DisplayMesh method unavailable.")
+            return
+        assert isinstance(mesh, SMESH_Mesh)
+        mesh_ds = mesh.GetMeshDS()  # the mesh data source
+        face_iter = mesh_ds.facesIterator()
+        # vertices positions are stored to a liste
+        vertices_position = []
+        for i in range(mesh_ds.NbFaces()-1):
+            face = face_iter.next()
+            #print('Face %i, type %i' % (i, face.GetType()))
+            #print(dir(face))
+            # if face.GetType == 3 : triangle mesh, then 3 nodes
+            for j in range(3):
+                node = face.GetNode(j)
+                #print('Coordinates of node %i:(%f,%f,%f)'%(i, node.X(), node.Y(), node.Z()))
+                vertices_position.append(node.X())
+                vertices_position.append(node.Y())
+                vertices_position.append(node.Z())
+        number_of_vertices = len(vertices_position)
+        # then we build the vertex and faces collections as numpy ndarrays
+        np_vertices = np.array(vertices_position, dtype='float32').reshape(int(number_of_vertices / 3), 3)
+        # Note: np_faces is just [0, 1, 2, 3, 4, 5, ...], thus arange is used
+        np_faces = np.arange(np_vertices.shape[0], dtype='uint32')
+        # set geometry properties
+        buffer_geometry_properties = {'position': BufferAttribute(np_vertices),
+                                      'index'   : BufferAttribute(np_faces)}
+        # build a BufferGeometry instance
+        mesh_geometry = BufferGeometry(attributes=buffer_geometry_properties)
+
+        mesh_geometry.exec_three_obj_method('computeVertexNormals')
+
+        # then a default material
+        mesh_material = MeshPhongMaterial(color=color,
+                                          polygonOffset=True,
+                                          polygonOffsetFactor=1,
+                                          polygonOffsetUnits=1,
+                                          shininess=0.5,
+                                          wireframe=False)
+        edges_material = MeshPhongMaterial(color='black',
+                                           polygonOffset=True,
+                                           polygonOffsetFactor=1,
+                                           polygonOffsetUnits=1,
+                                           shininess=0.5,
+                                           wireframe=True)
+        # create a mesh unique id
+        mesh_id = uuid.uuid4().hex
+
+        # finally create the mash
+        shape_mesh = Mesh(geometry=mesh_geometry,
+                          material=mesh_material,
+                          name=mesh_id)
+        edges_mesh = Mesh(geometry=mesh_geometry,
+                          material=edges_material,
+                          name=mesh_id)
+
+
+        # a special display for the mesh
+        camera_target = [0., 0., 0.]  # the point to look at
+        camera_position = [0, 0., 100.]  # the camera initial position
+        camera = PerspectiveCamera(position=camera_position,
+                                   lookAt=camera_target,
+                                   up=[0, 0, 1],
+                                   fov=50,
+                                   children=[DirectionalLight(color='#ffffff',
+                                                              position=[50, 50, 50],
+                                                              intensity=0.9)])
+        scene_shp = Scene(children=[shape_mesh, edges_mesh, camera, AmbientLight(color='#101010')])
+
+        renderer = Renderer(camera=camera,
+                            background=self._background,
+                            background_opacity=self._background_opacity,
+                            scene=scene_shp,
+                            controls=[OrbitControls(controlling=camera, target=camera_target)],
+                            width=self._size[0],
+                            height=self._size[1],
+                            antialias=True)
+
+        display(renderer)
+
+
+    def DisplayShape(self,
+                     shp,  # the TopoDS_Shape to be displayed
+                     shape_color=default_shape_color,  # the default
+                     render_edges=False,
+                     edge_color=default_edge_color,
+                     compute_uv_coords=False,
+                     quality=1.0,
+                     transparency=False,
+                     opacity=1.,
+                     topo_level='default',
+                     update=False):
+        """ Displays a topods_shape in the renderer instance.
+        shp: the TopoDS_Shape to render
+        shape_color: the shape color, in html corm, eg '#abe000'
+        render_edges: optional, False by default. If True, compute and dislay all
+                      edges as a linear interpolation of segments.
+        edge_color: optional, black by default. The color used for edge rendering,
+                    in html form eg '#ff00ee'
+        compute_uv_coords: optional, false by default. If True, compute texture
+                           coordinates (required if the shape has to be textured)
+        quality: optional, 1.0 by default. If set to something lower than 1.0,
+                      mesh will be more precise. If set to something higher than 1.0,
+                      mesh will be less precise, i.e. lower numer of triangles.
+        transparency: optional, False by default (opaque).
+        opacity: optional, float, by default to 1 (opaque). if transparency is set to True,
+                 0. is fully opaque, 1. is fully transparent.
+        detail_level: "default" by default. The value should be either "compound", "shape", "vertex".
+        update: optional, False by default. If True, render all the shapes.
+        """
+        if topo_level != "default":
+            t = TopologyExplorer(shp)
+            map_type_and_methods = {"Solid": t.solids, "Face": t.faces, "Shell": t.shells,
+                                    "Compound": t.compounds, "Compsolid": t.comp_solids}
+            for subshape in map_type_and_methods[topo_level]():
+                self.AddShapeToScene(subshape, shape_color, render_edges, edge_color, compute_uv_coords, quality,
+                                     transparency, opacity)
+        else:
+            self.AddShapeToScene(shp, shape_color, render_edges, edge_color, compute_uv_coords, quality,
+                                 transparency, opacity)
+
+        if update:
+            self.Display()
+
+
+    def AddShapeToScene(self,
+                        shp,  # the TopoDS_Shape to be displayed
+                        shape_color=default_shape_color,  # the default
+                        render_edges=False,
+                        edge_color=default_edge_color,
+                        compute_uv_coords=False,
+                        quality=1.0,
+                        transparency=False,
+                        opacity=1.):
+        # first, compute the tesselation
+        tess = Tesselator(shp)
+        tess.Compute(uv_coords=compute_uv_coords,
+                     compute_edges=render_edges,
+                     mesh_quality=quality,
+                     parallel=self._parallel)
+        # get vertices and normals
+        vertices_position = tess.GetVerticesPositionAsTuple()
+
+        number_of_triangles = tess.ObjGetTriangleCount()
+        number_of_vertices = len(vertices_position)
+
+        # number of vertices should be a multiple of 3
+        assert number_of_vertices % 3 == 0
+        assert number_of_triangles * 9 == number_of_vertices
+
+        # then we build the vertex and faces collections as numpy ndarrays
+        np_vertices = np.array(vertices_position, dtype='float32').reshape(int(number_of_vertices / 3), 3)
+        # Note: np_faces is just [0, 1, 2, 3, 4, 5, ...], thus arange is used
+        np_faces = np.arange(np_vertices.shape[0], dtype='uint32')
+
+        # set geometry properties
+        buffer_geometry_properties = {'position': BufferAttribute(np_vertices),
+                                      'index'   : BufferAttribute(np_faces)}
+        if self._compute_normals_mode == NORMAL.SERVER_SIDE:
+            # get the normal list, converts to a numpy ndarray. This should not raise
+            # any issue, since normals have been computed by the server, and are available
+            # as a list of floats
+            np_normals = np.array(tess.GetNormalsAsTuple(), dtype='float32').reshape(-1, 3)
+            # quick check
+            assert np_normals.shape == np_vertices.shape
+            buffer_geometry_properties['normal'] = BufferAttribute(np_normals)
+
+        # build a BufferGeometry instance
+        shape_geometry = BufferGeometry(attributes=buffer_geometry_properties)
+
+        # if the client has to render normals, add the related js instructions
+        if self._compute_normals_mode == NORMAL.CLIENT_SIDE:
+            shape_geometry.exec_three_obj_method('computeVertexNormals')
+
+        # then a default material
+        shp_material = MeshPhongMaterial(color=shape_color,
+                                         polygonOffset=True,
+                                         polygonOffsetFactor=1,
+                                         polygonOffsetUnits=1,
+                                         shininess=0.9,
+                                         transparent=transparency,
+                                         opacity=opacity)
+
+        # create a mesh unique id
+        mesh_id = uuid.uuid4().hex
+
+        # finally create the mash
+        shape_mesh = Mesh(geometry=shape_geometry,
+                          material=shp_material,
+                          name=mesh_id)
+
+
+        # and to the dict of shapes, to have a mapping between meshes and shapes
+        self._shapes[mesh_id] = shp
+
+        # edge rendering, if set to True
+        edge_lines = None
+        if render_edges:
+            edges = list(map(lambda i_edge: [tess.GetEdgeVertex(i_edge, i_vert) for i_vert in range(tess.ObjEdgeGetVertexCount(i_edge))], range(tess.ObjGetEdgeCount())))
+            edges = list(filter(lambda edge: len(edge) == 2, edges))
+            np_edge_vertices = np.array(edges, dtype=np.float32).reshape(-1, 3)
+            np_edge_indices = np.arange(np_edge_vertices.shape[0], dtype=np.uint32)
+            edge_geometry = BufferGeometry(attributes={
+                'position': BufferAttribute(np_edge_vertices),
+                'index'   : BufferAttribute(np_edge_indices)
+            })
+            edge_material = LineBasicMaterial(color=edge_color, linewidth=1)
+            edge_lines = LineSegments(geometry=edge_geometry, material=edge_material)
+
+        # Add geometries to pickable or non pickable objects
+        self._displayed_pickable_objects.add(shape_mesh)
+        if render_edges:
+            self._displayed_non_pickable_objects.add(edge_lines)
+
+
+    def EraseAll(self):
+        self._shapes = {}
+        self._displayed_pickable_objects = Group()
+        self._current_shape_selection = None
+        self._current_mesh_selection = None
+        self._current_selection_material = None
+        self._renderer.scene = Scene(children=[])
+
+
+    def Display(self):
+        self._update_camera()
+        scene_shp = Scene(children=[self._displayed_pickable_objects,
+                                    self._displayed_non_pickable_objects,
+                                    self._camera,
+                                    AmbientLight(color='#101010')])
+
+        self._renderer = Renderer(camera=self._camera,
+                                  background=self._background,
+                                  background_opacity=self._background_opacity,
+                                  scene=scene_shp,
+                                  controls=[OrbitControls(controlling=self._camera, target=self._camera_target), self._picker],
+                                  width=self._size[0],
+                                  height=self._size[1],
+                                  antialias=True)
+        # then display both 3d widgets and webui
+        display(HBox([self._renderer, self.html]))
+
+
+    def __repr__(self):
+        self.Display()
+        return ""
