diff --git a/CMakeLists.txt b/CMakeLists.txt
index a442dc7..164aa54 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -351,6 +351,7 @@ endif(PYTHONOCC_WRAP_VISU)
 install(FILES ${BUILD_DIR}/Addons.py DESTINATION ${PYTHONOCC_INSTALL_DIRECTORY} )
 install(TARGETS _Addons DESTINATION ${PYTHONOCC_INSTALL_DIRECTORY} )
 install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/src/Display DESTINATION ${PYTHONOCC_INSTALL_DIRECTORY} )
+install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/src/Extend DESTINATION ${PYTHONOCC_INSTALL_DIRECTORY} )
 # install LICENSE file
 install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/LICENSE DESTINATION ${PYTHONOCC_INSTALL_DIRECTORY} )
 # install AUTHORS file
diff --git a/src/Display/OCCViewer.py b/src/Display/OCCViewer.py
index 25d2411..a4b8b7b 100644
--- a/src/Display/OCCViewer.py
+++ b/src/Display/OCCViewer.py
@@ -1,6 +1,6 @@
 #!/usr/bin/env python
 
-##Copyright 2008-2014 Thomas Paviot (tpaviot@gmail.com)
+##Copyright 2008-2017 Thomas Paviot (tpaviot@gmail.com)
 ##
 ##This file is part of pythonOCC.
 ##
@@ -20,45 +20,69 @@
 from __future__ import print_function
 
 import os
+import os.path
+import time
 import sys
 import math
 import itertools
 
-from OCC.AIS import AIS_MultipleConnectedInteractive, AIS_Shape
+import OCC
+from OCC.Aspect import Aspect_GFM_VER
+from OCC.AIS import AIS_Shape, AIS_Shaded, AIS_TexturedShape, AIS_WireFrame
 from OCC.TopoDS import TopoDS_Shape
 from OCC.gp import gp_Dir, gp_Pnt, gp_Pnt2d, gp_Vec
 from OCC.BRepBuilderAPI import (BRepBuilderAPI_MakeVertex,
-                                BRepBuilderAPI_MakeEdge,
-                                BRepBuilderAPI_MakeEdge2d,
-                                BRepBuilderAPI_MakeFace)
+                                     BRepBuilderAPI_MakeEdge,
+                                     BRepBuilderAPI_MakeEdge2d,
+                                     BRepBuilderAPI_MakeFace)
 from OCC.TopAbs import (TopAbs_FACE, TopAbs_EDGE, TopAbs_VERTEX,
-                        TopAbs_SHELL, TopAbs_SOLID)
-from OCC.Geom import Handle_Geom_Curve, Handle_Geom_Surface
-from OCC.Geom2d import Handle_Geom2d_Curve
-import OCC.Visualization
-import OCC.V3d
-import OCC.AIS
+                             TopAbs_SHELL, TopAbs_SOLID)
+from OCC.Geom import Geom_Curve, Geom_Surface, Handle_Geom_Curve, Handle_Geom_Surface
+from OCC.Geom2d import Geom2d_Curve, Handle_Geom2d_Curve
+from OCC.Visualization import Display3d
+from OCC.V3d import (V3d_ZBUFFER, V3d_PHONG, V3d_Zpos, V3d_Zneg, V3d_Xpos,
+                          V3d_Xneg, V3d_Ypos, V3d_Yneg, V3d_XposYnegZpos, V3d_TEX_ALL,
+                          V3d_TEX_NONE, V3d_TEX_ENVIRONMENT,
+                          V3d_LayerMgr)
 from OCC.TCollection import TCollection_ExtendedString, TCollection_AsciiString
 from OCC.Quantity import (Quantity_Color, Quantity_TOC_RGB, Quantity_NOC_WHITE,
-                          Quantity_NOC_BLACK, Quantity_NOC_BLUE1,
-                          Quantity_NOC_CYAN1, Quantity_NOC_RED,
-                          Quantity_NOC_GREEN,
-                          Quantity_NOC_ORANGE, Quantity_NOC_YELLOW)
-from OCC.Prs3d import (Prs3d_Arrow, Prs3d_Presentation, Prs3d_Text,
-                       Prs3d_TextAspect)
-from OCC.Graphic3d import Graphic3d_NOM_NEON_GNC
-from OCC.V3d import V3d_ZBUFFER
-from OCC.Aspect import Aspect_TOTP_RIGHT_LOWER
-
-#
-# On Windows, the CSF_GraphicShr env variable must be set up
-# and point to the TKOpenGl.dll library.
-#
-if sys.platform == "win32":  # all of this is win specific
-    # if the CSF_GraphicShr variable is not set
-    # it should point to the TKOpenGl.dll library that is shipped with pythonocc binary
-    if not "CSF_GraphicShr" in os.environ:
-        os.environ["CSF_GraphicShr"] = os.path.join(os.path.dirname(OCC.Aspect.__file__), "TKOpenGl.dll")
+                               Quantity_NOC_BLACK, Quantity_NOC_BLUE1,
+                               Quantity_NOC_CYAN1, Quantity_NOC_RED,
+                               Quantity_NOC_GREEN, Quantity_NOC_ORANGE, Quantity_NOC_YELLOW)
+from OCC.Prs3d import Prs3d_Arrow, Prs3d_Presentation, Prs3d_Text, Prs3d_TextAspect
+from OCC.Graphic3d import (Graphic3d_NOM_NEON_GNC, Graphic3d_NOT_ENV_CLOUDS,
+                                Handle_Graphic3d_TextureEnv, Graphic3d_TextureEnv,
+                                Graphic3d_Camera, Graphic3d_RM_RAYTRACING,
+                                Graphic3d_RM_RASTERIZATION,
+                                Graphic3d_RenderingParams)
+from OCC.Aspect import Aspect_TOTP_RIGHT_LOWER, Aspect_FM_STRETCH, Aspect_FM_NONE
+
+# Shaders and Units definition must be found by occ
+# the fastest way to get done is to set the CASROOT env variable
+# it must point to the /share folder.
+if sys.platform == "win32":
+    # do the same for Units
+    if "CASROOT" in os.environ:
+        casroot_path = os.environ["CASROOT"]
+        # raise an error, force the user to correctly set the variable
+        err_msg = "Please set the CASROOT env variable (%s is not ok)" % casroot_path
+        if not os.path.isdir(casroot_path):
+        	raise AssertionError(err_msg)
+    else:  # on miniconda or anaconda or whatever conda
+        occ_package_path = os.path.dirname(OCC.__file__)
+        casroot_path = os.path.join(occ_package_path, '..', '..', '..',
+                                    'Library', 'share', 'oce')
+        # we check that all required files are at the right place
+        shaders_dict_found = os.path.isdir(os.path.join(casroot_path,
+                                                        'src', 'Shaders'))
+        unitlexicon_found = os.path.isfile(os.path.join(casroot_path,
+                                                        'src', 'UnitsAPI',
+                                                        'Lexi_Expr.dat'))
+        unitsdefinition_found = os.path.isfile(os.path.join(casroot_path,
+                                                            'src', 'UnitsAPI',
+                                                            'Units.dat'))
+        if shaders_dict_found and unitlexicon_found and unitsdefinition_found:
+            os.environ["CASROOT"] = casroot_path
 
 
 def rgb_color(r, g, b):
@@ -73,7 +97,6 @@ def get_color_from_name(color_name):
     enum_name = 'Quantity_NOC_%s' % color_name.upper()
     if enum_name in globals():
         color_num = globals()[enum_name]
-        return Quantity_Color(color_num)
     elif enum_name+'1' in globals():
         color_num = globals()[enum_name+'1']
         print('Many colors for color name %s, using first.' % color_name)
@@ -92,9 +115,10 @@ modes = itertools.cycle([TopAbs_FACE, TopAbs_EDGE,
                          TopAbs_SHELL, TopAbs_SOLID])
 
 
-class Viewer3d(OCC.Visualization.Display3d):
-    def __init__(self, window_handle):
-        OCC.Visualization.Display3d.__init__(self)
+class Viewer3d(Display3d):
+    def __init__(self, window_handle, parent=None):
+        Display3d.__init__(self)
+        self._parent = parent  # the parent opengl GUI container
         self._window_handle = window_handle
         self._inited = False
         self._local_context_opened = False
@@ -104,11 +128,27 @@ class Viewer3d(OCC.Visualization.Display3d):
         self.Context = None
         self.Viewer = None
         self.View = None
-        self.selected_shape = None
+        self.OverLayer = None
         self.default_drawer = None
         self._struc_mgr = None
+        self._is_offscreen = None
+
         self.selected_shapes = []
         self._select_callbacks = []
+        self._overlay_items = []
+
+    def get_parent(self):
+        return self._parent
+
+    def register_overlay_item(self, overlay_item):
+        self._overlay_items.append(overlay_item)
+        self.View.MustBeResized()
+        self.View.Redraw()
+
+    def GetOverLayer(self):
+        """ returns an handle to the current overlayer
+        """
+        return self.OverLayer
 
     def register_select_callback(self, callback):
         """ Adds a callback that will be called each time a shape s selected
@@ -134,7 +174,11 @@ class Viewer3d(OCC.Visualization.Display3d):
         self.View.FitAll()
 
     def Create(self, create_default_lights=True, draw_face_boundaries=True, phong_shading=True):
-        self.Init(self._window_handle)
+        if self._window_handle is None:
+            self.InitOffscreen(640, 480)
+            self._is_offscreen = True
+        else:
+            self.Init(self._window_handle)
         self.Context_handle = self.GetContext()
         self.Viewer_handle = self.GetViewer()
         self.View_handle = self.GetView()
@@ -156,21 +200,28 @@ class Viewer3d(OCC.Visualization.Display3d):
         self.default_drawer.SetMaximalChordialDeviation(chord_dev)
 
         if phong_shading:
-            # gouraud shading by defauly, prefer phong instead
-            self.View.SetShadingModel(OCC.V3d.V3d_PHONG)
+            # gouraud shading by default, prefer phong instead
+            self.View.SetShadingModel(V3d_PHONG)
 
         # the selected elements gray by default, better to use orange...
         # self.Context.SelectionColor(Quantity_NOC_ORANGE)
 
-        # nessecary for text rendering
+        # necessary for text rendering
         self._struc_mgr = self.Context.MainPrsMgr().GetObject().StructureManager()
-        self._inited = True
 
-    def SetDoubleBuffer(self, on_or_off):
-        """enables double buffering when shapes are moved in the viewer
-        a very shaky picture is drawn, since double buffering
-        is disabled by default. fixed here..."""
-        self.View.Window().GetObject().SetDoubleBuffer(bool(on_or_off))
+        # overlayer
+        self.OverLayer = self.Viewer.Viewer().GetObject().OverLayer().GetObject()
+        if self.OverLayer is None:
+            aMgr = V3d_LayerMgr(self.View.GetHandle())
+            self.OverLayer = aMgr.Overlay().GetObject()
+            self.View.SetLayerMgr(aMgr.GetHandle())
+        print("Layer manager created")
+        height, width = self.View.Window().GetObject().Size()
+        print("Layer dimensions: %i, %i" % (height, width))
+        self.OverLayer.SetViewport(height, width)
+
+        # turn self._inited flag to True
+        self._inited = True
 
     def OnResize(self):
         self.View.MustBeResized()
@@ -179,68 +230,138 @@ class Viewer3d(OCC.Visualization.Display3d):
         self.View.Reset()
 
     def Repaint(self):
+        # overlayed objects
+        self.OverLayer.Begin()
+        for item in self._overlay_items:
+            item.RedrawLayerPrs()
+        self.OverLayer.End()
+        # finally redraw the view
         self.Viewer.Redraw()
 
     def SetModeWireFrame(self):
         self.View.SetComputedMode(False)
-        self.Context.SetDisplayMode(OCC.AIS.AIS_WireFrame)
+        self.Context.SetDisplayMode(AIS_WireFrame)
 
     def SetModeShaded(self):
         self.View.SetComputedMode(False)
-        self.Context.SetDisplayMode(OCC.AIS.AIS_Shaded)
-        self.EnableAntiAliasing()
+        self.Context.SetDisplayMode(AIS_Shaded)
 
     def SetModeHLR(self):
         self.View.SetComputedMode(True)
 
-    def SetOrthographic(self, _bool):
-        '''
-        sets whether this view is a orthographic or perspective view
-        @param _bool:
-        '''
-        raise AssertionError("SetOrthographic method not yet implemented.")
+    def SetOrthographicProjection(self):
+        self.camera.SetProjectionType(Graphic3d_Camera.Projection_Orthographic)
+
+    def SetPerspectiveProjection(self):
+        self.camera.SetProjectionType(Graphic3d_Camera.Projection_Perspective)
 
     def View_Top(self):
-        self.View.SetProj(OCC.V3d.V3d_Zpos)
+        self.View.SetProj(V3d_Zpos)
 
     def View_Bottom(self):
-        self.View.SetProj(OCC.V3d.V3d_Zneg)
+        self.View.SetProj(V3d_Zneg)
 
     def View_Left(self):
-        self.View.SetProj(OCC.V3d.V3d_Xneg)
+        self.View.SetProj(V3d_Xneg)
 
     def View_Right(self):
-        self.View.SetProj(OCC.V3d.V3d_Xpos)
+        self.View.SetProj(V3d_Xpos)
 
     def View_Front(self):
-        self.View.SetProj(OCC.V3d.V3d_Yneg)
+        self.View.SetProj(V3d_Yneg)
 
     def View_Rear(self):
-        self.View.SetProj(OCC.V3d.V3d_Ypos)
+        self.View.SetProj(V3d_Ypos)
 
     def View_Iso(self):
-        self.View.SetProj(OCC.V3d.V3d_XposYnegZpos)
+        self.View.SetProj(V3d_XposYnegZpos)
+
+    def EnableTextureEnv(self, name_of_texture=Graphic3d_NOT_ENV_CLOUDS):
+        """ enable environment mapping. Possible modes are
+        Graphic3d_NOT_ENV_CLOUDS
+        Graphic3d_NOT_ENV_CV
+        Graphic3d_NOT_ENV_MEDIT
+        Graphic3d_NOT_ENV_PEARL
+        Graphic3d_NOT_ENV_SKY1
+        Graphic3d_NOT_ENV_SKY2
+        Graphic3d_NOT_ENV_LINES
+        Graphic3d_NOT_ENV_ROAD
+        Graphic3d_NOT_ENV_UNKNOWN
+        """
+        texture_env = Graphic3d_TextureEnv(name_of_texture)
+        self.View.SetTextureEnv(texture_env)
+        self.View.SetSurfaceDetail(V3d_TEX_ENVIRONMENT)
+        self.View.Redraw()
+
+    def DisableTextureEnv(self):
+        self.View.SetSurfaceDetail(V3d_TEX_NONE)
+        a_null_texture = Handle_Graphic3d_TextureEnv()
+        self.View.SetTextureEnv(a_null_texture) # Passing null handle to clear the texture data
+        self.View.Redraw()
+
+    def SetRenderingParams(self,
+                           Method=Graphic3d_RM_RASTERIZATION,
+                           RaytracingDepth=3,
+                           IsShadowEnabled=True,
+                           IsReflectionEnabled=False,
+                           IsAntialiasingEnabled=False,
+                           IsTransparentShadowEnabled=False,
+                           StereoMode=0,
+                           AnaglyphFilter=0,
+                           ToReverseStereo=False):
+        """ Default values are :
+            Method=Graphic3d_RM_RASTERIZATION,
+            RaytracingDepth=3,
+            IsShadowEnabled=True,
+            IsReflectionEnabled=False,
+            IsAntialiasingEnabled=False,
+            IsTransparentShadowEnabled=False,
+            StereoMode=Graphic3d_StereoMode_QuadBuffer,
+            AnaglyphFilter=Graphic3d_RenderingParams.Anaglyph_RedCyan_Optimized,
+            ToReverseStereo=False)
+        """
+        self.ChangeRenderingParams(Method,
+                                   RaytracingDepth,
+                                   IsShadowEnabled,
+                                   IsReflectionEnabled,
+                                   IsAntialiasingEnabled,
+                                   IsTransparentShadowEnabled,
+                                   StereoMode,
+                                   AnaglyphFilter,
+                                   ToReverseStereo)
+
+    def SetRasterizationMode(self):
+        """ to enable rasterization mode, just call the SetRenderingParams
+        with default values
+        """
+        self.SetRenderingParams()
+
+    def SetRaytracingMode(self, depth=3):
+        """ enables the raytracing mode
+        """
+        self.SetRenderingParams(Method=Graphic3d_RM_RAYTRACING,
+                                RaytracingDepth=depth,
+                                IsAntialiasingEnabled=True,
+                                IsShadowEnabled=True,
+                                IsReflectionEnabled=True,
+                                IsTransparentShadowEnabled=True)
 
     def ExportToImage(self, image_filename):
         self.View.Dump(image_filename)
 
-    def set_raytracing_mode(self, shadows=True, reflections=True, antialiasing=True):
-        self.View.SetRaytracingMode()
-        if shadows:
-            self.View.EnableRaytracedShadows()
-        if reflections:
-            self.View.EnableRaytracedReflections()
-        if antialiasing:
-            self.View.EnableRaytracedAntialiasing()
-
     def display_graduated_trihedron(self):
         self.View.GraduatedTrihedronDisplay()
 
     def display_trihedron(self):
-        """ Show a black trihedron in lower right corner
+        """ Show a black triedron in lower right corner
         """
         self.View.TriedronDisplay(Aspect_TOTP_RIGHT_LOWER, Quantity_NOC_BLACK, 0.1, V3d_ZBUFFER)
 
+    def hide_triedron(self):
+        """ Show a black triedron in lower right corner
+        """
+        self.View.TriedronErase()
+
     def set_bg_gradient_color(self, R1, G1, B1, R2, G2, B2):
         """ set a bg vertical gradient color.
         R, G and B are floats.
@@ -250,14 +371,18 @@ class Viewer3d(OCC.Visualization.Display3d):
         self.View.SetBgGradientColors(aColor1, aColor2, 2, True)
 
     def SetBackgroundImage(self, image_filename, stretch=True):
+        """ displays a background image (jpg, png etc.)
+        """
         if not os.path.isfile(image_filename):
             raise IOError("image file %s not found." % image_filename)
         if stretch:
-            self.View.SetBackgroundImage(image_filename, OCC.Aspect.Aspect_FM_STRETCH, True)
+            self.View.SetBackgroundImage(image_filename, Aspect_FM_STRETCH, True)
         else:
-            self.View.SetBackgroundImage(image_filename, OCC.Aspect.Aspect_FM_NONE, True)
+            self.View.SetBackgroundImage(image_filename, Aspect_FM_NONE, True)
 
     def DisplayVector(self, vec, pnt, update=False):
+        """ displays a vector as an arrow
+        """
         if self._inited:
             aPresentation = Prs3d_Presentation(self._struc_mgr)
 
@@ -266,7 +391,7 @@ class Viewer3d(OCC.Visualization.Display3d):
             pnt_start = gp_Pnt(start.X(), start.Y(), start.Z())
 
             Prs3d_Arrow.Draw(
-                aPresentation.GetHandle(),
+                aPresentation,
                 pnt_start,
                 gp_Dir(vec),
                 math.radians(20),
@@ -294,8 +419,8 @@ class Viewer3d(OCC.Visualization.Display3d):
             text_aspect.SetHeight(height)
         if isinstance(point, gp_Pnt2d):
             point = gp_Pnt(point.X(), point.Y(), 0)
-        Prs3d_Text.Draw(aPresentation.GetHandle(),
-                        text_aspect.GetHandle(),
+        Prs3d_Text.Draw(aPresentation,
+                        text_aspect,
                         to_string(text_to_write),
                         point)
         aPresentation.Display()
@@ -306,8 +431,9 @@ class Viewer3d(OCC.Visualization.Display3d):
         return aPresentation
 
     def DisplayShape(self, shapes, material=None, texture=None, color=None, transparency=None, update=False):
-        '''
-        '''
+        """ display one or a set of displayable objects
+        """
+        SOLO = False  # assume multiple instances by default
         # if a gp_Pnt is passed, first convert to vertex
         if issubclass(shapes.__class__, gp_Pnt):
             vertex = BRepBuilderAPI_MakeVertex(shapes)
@@ -355,16 +481,14 @@ class Viewer3d(OCC.Visualization.Display3d):
         elif issubclass(shapes.__class__, TopoDS_Shape):
             shapes = [shapes]
             SOLO = True
-        else:
-            SOLO = False
 
         ais_shapes = []
 
         for shape in shapes:
             if material or texture:
                 if texture:
-                    self.View.SetSurfaceDetail(OCC.V3d.V3d_TEX_ALL)
-                    shape_to_display = OCC.AIS.AIS_TexturedShape(shape)
+                    self.View.SetSurfaceDetail(V3d_TEX_ALL)
+                    shape_to_display = AIS_TexturedShape(shape)
                     filename, toScaleU, toScaleV, toRepeatU, toRepeatV, originU, originV = texture.GetProperties()
                     shape_to_display.SetTextureFileName(TCollection_AsciiString(filename))
                     shape_to_display.SetTextureMapOn()
@@ -386,10 +510,14 @@ class Viewer3d(OCC.Visualization.Display3d):
             # computing graphic properties is expensive
             # if an iterable is found, so cluster all TopoDS_Shape under
             # an AIS_MultipleConnectedInteractive
-            shape_to_display = AIS_MultipleConnectedInteractive()
-            for i in ais_shapes:
-                shape_to_display.Connect(i)
-
+            #shape_to_display = AIS_MultipleConnectedInteractive()
+            for ais_shp in ais_shapes:
+                # TODO : following line crashes with oce-0.18
+                # why ? fix ?
+                #shape_to_display.Connect(i)
+                self.Context.Display(ais_shp, False)
+            shape_to_display = ais_shapes
+            return shape_to_display
         # set the graphic properties
         if material is None:
             #The default material is too shiny to show the object
@@ -411,10 +539,7 @@ class Viewer3d(OCC.Visualization.Display3d):
         else:
             self.Context.Display(shape_to_display.GetHandle(), False)
 
-        if SOLO:
-            return ais_shapes[0]
-        else:
-            return shape_to_display
+        return shape_to_display
 
     def DisplayColoredShape(self, shapes, color='YELLOW', update=False, ):
         if isinstance(color, str):
@@ -464,13 +589,13 @@ class Viewer3d(OCC.Visualization.Display3d):
         self.Context.UpdateSelected()
 
     def SetSelectionModeVertex(self):
-        self.SetSelectionMode(OCC.TopAbs.TopAbs_VERTEX)
+        self.SetSelectionMode(TopAbs_VERTEX)
 
     def SetSelectionModeEdge(self):
-        self.SetSelectionMode(OCC.TopAbs.TopAbs_EDGE)
+        self.SetSelectionMode(TopAbs_EDGE)
 
     def SetSelectionModeFace(self):
-        self.SetSelectionMode(OCC.TopAbs.TopAbs_FACE)
+        self.SetSelectionMode(TopAbs_FACE)
 
     def SetSelectionModeShape(self):
         self.Context.CloseAllContexts()
@@ -544,3 +669,41 @@ class Viewer3d(OCC.Visualization.Display3d):
 
     def StartRotation(self, X, Y):
         self.View.StartRotation(X, Y)
+
+
+class OffscreenRenderer(Viewer3d):
+    """ The offscreen renderer is inherited from Viewer3d.
+    The DisplayShape method is overriden to export to image
+    each time it is called.
+    """
+    def __init__(self, screen_size=(640, 480)):
+        Viewer3d.__init__(self, None)
+        # create the renderer
+        self.Create()
+        self.SetSize(screen_size[0], screen_size[1])
+        self.SetModeShaded()
+        self.set_bg_gradient_color([206, 215, 222], [128, 128, 128])
+        self.display_triedron()
+        self.capture_number = 0
+
+    def DisplayShape(self, shapes, material=None, texture=None, color=None, transparency=None, update=True):
+        # call the "original" DisplayShape method
+        r = super(OffscreenRenderer, self).DisplayShape(shapes, material, texture,
+                                                        color, transparency, update)  # always update
+        if os.getenv("PYTHONOCC_OFFSCREEN_RENDERER_DUMP_IMAGE") == "1":  # dump to jpeg file
+            timestamp = ("%f" % time.time()).split(".")[0]
+            self.capture_number += 1
+            image_filename = "capture-%i-%s.jpeg" % (self.capture_number,
+                                                     timestamp.replace(" ", "-"))
+            if os.getenv("PYTHONOCC_OFFSCREEN_RENDERER_DUMP_IMAGE_PATH"):
+                path = os.getenv("PYTHONOCC_OFFSCREEN_RENDERER_DUMP_IMAGE_PATH")
+                if not os.path.isdir(path):
+                	raise IOError("%s is not a valid path" % path)
+            else:
+                path = os.getcwd()
+            image_full_name = os.path.join(path, image_filename)
+            self.View.Dump(image_full_name)
+            if not os.path.isfile(image_full_name):
+            	raise IOError("OffscreenRenderer failed to render image to file")
+            print("OffscreenRenderer content dumped to %s" % image_full_name)
+        return r
diff --git a/src/Visualization/Display3d.cpp b/src/Visualization/Display3d.cpp
index 147247e..3d3a8ad 100644
--- a/src/Visualization/Display3d.cpp
+++ b/src/Visualization/Display3d.cpp
@@ -21,6 +21,7 @@
 
 
 Display3d::Display3d()
+  : myIsOffscreen(false)
 {
 }
 
@@ -28,12 +29,128 @@ Display3d::~Display3d()
 {
 }
 
-static Handle(Graphic3d_GraphicDriver)& GetGraphicDriver()
+static Handle(OpenGl_GraphicDriver)& GetGraphicDriver()
 {
-  static Handle(Graphic3d_GraphicDriver) aGraphicDriver;
+  static Handle(OpenGl_GraphicDriver) aGraphicDriver;
   return aGraphicDriver;
 }
 
+//=========================================================
+// Function : WClass
+// Purpose  :
+//=========================================================
+static const Handle(MMgt_TShared)& WClass()
+{
+  static Handle(MMgt_TShared) aWindowClass;
+#ifdef WNT
+  if (aWindowClass.IsNull())
+  {
+    aWindowClass = new WNT_WClass ("PyOCC_Class", (void*)DefWindowProc,
+                                   CS_VREDRAW | CS_HREDRAW, 0, 0,
+                                   ::LoadCursor (NULL, IDC_ARROW));
+  }
+#endif
+  return aWindowClass;
+}
+
+
+Standard_Boolean Display3d::InitOffscreen(int size_x, int size_y)
+{
+  printf(" ###### 3D rendering pipe initialisation #####\n");
+  printf("Display3d class initialization starting ...\n");
+
+  myIsOffscreen = true;
+
+  // Create graphic driver
+  Handle(Aspect_DisplayConnection) aDisplayConnection = new Aspect_DisplayConnection();
+  printf("Aspect_DisplayConnection created.\n");
+  if (GetGraphicDriver().IsNull())
+  {
+    GetGraphicDriver() = new OpenGl_GraphicDriver (aDisplayConnection);
+  }
+  printf("Graphic_Driver created.\n");
+  // Create V3dViewer and V3d_View
+  myV3dViewer = new V3d_Viewer(GetGraphicDriver(), (short* const)"viewer");
+  printf("V3d_Viewer created.\n");
+  // Create AISInteractiveViewer
+  myAISContext = new AIS_InteractiveContext(myV3dViewer);
+  printf("AIS_InteractiveContext created.\n");
+  // Create view
+  myV3dView = myV3dViewer->CreateView();  
+  printf("V3d_View created\n");
+
+  SetSize(size_x, size_y);
+
+  printf("Display3d class successfully initialized.\n");
+  printf(" ########################################\n");
+  return true;
+}
+
+Standard_Boolean Display3d::IsOffscreen()
+{
+  return myIsOffscreen;
+}
+
+Standard_Boolean Display3d::SetSize(int size_x, int size_y)
+{
+  if(myIsOffscreen)
+  {
+    mySizeX = size_x;
+    mySizeY = size_y;
+
+#ifdef WNT
+      myWindow = new WNT_Window ("PythonOCC",
+                                    Handle(WNT_WClass)::DownCast (WClass()),
+                                    WS_OVERLAPPEDWINDOW,
+                                    0, 0,
+                                    size_x, size_y,
+                                    Quantity_NOC_BLACK);
+      myWindow->SetVirtual (true);
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+      myWindow = new Cocoa_Window("PythonOCC",
+                                  0, 0,
+                                  size_x, size_y);
+      printf("Cocoa window created.\n");
+      myWindow->SetVirtual (true);
+#else
+      myWindow = new Xw_Window (myAISContext->CurrentViewer()->Driver()->GetDisplayConnection(),
+                                   "PythonOCC",
+                                   0, 0,
+                                   size_x, size_y);
+      myWindow->SetVirtual (true);
+#endif
+    myV3dView->SetWindow(myWindow);
+    return true;
+  }
+  return false;
+}
+
+Standard_Boolean Display3d::GetSize(int &size_x, int &size_y)
+{
+  if(myIsOffscreen)
+  {
+    size_x = mySizeX;
+    size_y = mySizeY;
+    return true;
+  }
+  return false;
+}
+
+Standard_Boolean Display3d::GetImageData(const char* &data, size_t &size, const Graphic3d_BufferType& theBufferType)
+{
+  if(myIsOffscreen)
+  {
+    static Image_PixMap anImage;
+    if (myV3dView->ToPixMap (anImage, mySizeX, mySizeY, theBufferType))
+    {
+      data = (const char*)anImage.Data();
+      size = anImage.SizeBytes();
+      return true;
+    }
+  }
+  return false;
+}
+
 void Display3d::Init(long window_handle)
 {
   printf(" ###### 3D rendering pipe initialisation #####\n");
@@ -73,6 +190,52 @@ void Display3d::Init(long window_handle)
 	printf(" ########################################\n");
 }
 
+void Display3d::ChangeRenderingParams(int Method,
+                                      Standard_Integer RaytracingDepth,
+                                      Standard_Boolean IsShadowEnabled,
+                                      Standard_Boolean IsReflectionEnabled,
+                                      Standard_Boolean IsAntialiasingEnabled,
+                                      Standard_Boolean IsTransparentShadowEnabled,
+                                      int StereoMode,
+                                      int AnaglyphFilter,
+                                      Standard_Boolean ToReverseStereo)
+{
+  Graphic3d_RenderingParams& aParams = myV3dView->ChangeRenderingParams();
+  aParams.Method = (Graphic3d_RenderingMode)Method;
+  aParams.RaytracingDepth = RaytracingDepth;
+  aParams.IsShadowEnabled = IsShadowEnabled;
+  aParams.IsAntialiasingEnabled = IsAntialiasingEnabled;
+  aParams.IsReflectionEnabled = IsReflectionEnabled;
+  aParams.IsTransparentShadowEnabled = IsTransparentShadowEnabled;
+  //aParams.StereoMode = (Graphic3d_StereoMode)StereoMode;
+  //aParams.AnaglyphFilter = (Graphic3d_RenderingParams::Anaglyph)AnaglyphFilter;
+  //aParams.ToReverseStereo =ToReverseStereo;
+  myV3dView->Redraw();
+}
+
+void Display3d::SetAnaglyphMode(int mode)
+{
+ /* Handle(Graphic3d_Camera) aCamera = myV3dView->Camera();
+  Graphic3d_RenderingParams* aParams = &myV3dView->ChangeRenderingParams();
+  
+  aParams->StereoMode = Graphic3d_StereoMode_Anaglyph;
+  aParams->AnaglyphFilter = (Graphic3d_RenderingParams::Anaglyph)mode;
+
+  GetGraphicDriver()->ChangeOptions().contextStereo = true;
+  aCamera->SetProjectionType (Graphic3d_Camera::Projection_Stereo);
+  myV3dView->Redraw();*/
+}
+
+void Display3d::EnableVBO()
+{
+  GetGraphicDriver()->ChangeOptions().vboDisable = false;
+}
+
+void Display3d::DisableVBO()
+{
+  GetGraphicDriver()->ChangeOptions().vboDisable = true;
+}
+
 void Display3d::Test()
 {
       BRepPrimAPI_MakeBox S(100,50,40);
diff --git a/src/Visualization/Tesselator.cpp b/src/Visualization/Tesselator.cpp
index e373369..8d5c794 100644
--- a/src/Visualization/Tesselator.cpp
+++ b/src/Visualization/Tesselator.cpp
@@ -74,6 +74,7 @@ Tesselator::Tesselator(TopoDS_Shape   aShape,
     locVertexcoord = NULL;
     locNormalcoord = NULL;
     locTexcoord    = NULL;
+    loc_tri_indexes = NULL;
     ComputeDefaultDeviation();
 }
 
@@ -95,16 +96,17 @@ Tesselator::Tesselator(TopoDS_Shape   aShape) :
     locVertexcoord = NULL;
     locNormalcoord = NULL;
     locTexcoord    = NULL;
+    loc_tri_indexes = NULL;
     ComputeDefaultDeviation();
 }
 
-void Tesselator::Compute(bool uv_coords, bool compute_edges, float mesh_quality)
+void Tesselator::Compute(bool uv_coords, bool compute_edges, float mesh_quality, bool parallel)
 {
   if (uv_coords) {
-    TesselateWithUVCoords(compute_edges, mesh_quality);
+    TesselateWithUVCoords(compute_edges, mesh_quality, parallel);
   }
   else {
-    Tesselate(compute_edges, mesh_quality);
+    Tesselate(compute_edges, mesh_quality, parallel);
   }
 }
 
@@ -141,7 +143,7 @@ void Tesselator::SetDeviation(Standard_Real aDeviation)
 
 
 //---------------------------------------------------------------------------
-void Tesselator::Tesselate(bool compute_edges, float mesh_quality)
+void Tesselator::Tesselate(bool compute_edges, float mesh_quality, bool parallel)
 {
     TopExp_Explorer       ExpFace;
     StdPrs_ToolShadedShape   SST;
@@ -153,7 +155,7 @@ void Tesselator::Tesselate(bool compute_edges, float mesh_quality)
     gp_Pnt2d d_coord;
 
     //Triangulate
-    BRepMesh_IncrementalMesh(myShape, myDeviation*mesh_quality, false, 0.5*mesh_quality, false);
+    BRepMesh_IncrementalMesh(myShape, myDeviation*mesh_quality, false, 0.5*mesh_quality, parallel);
 
 
     for (ExpFace.Init(myShape, TopAbs_FACE); ExpFace.More(); ExpFace.Next()) {
@@ -226,7 +228,7 @@ void Tesselator::Tesselate(bool compute_edges, float mesh_quality)
 }
 
 //---------------------------------------------------------------------------
-void Tesselator::TesselateWithUVCoords(bool compute_edges, float mesh_quality)
+void Tesselator::TesselateWithUVCoords(bool compute_edges, float mesh_quality, bool parallel)
 {
   Standard_Real Umin;
   Standard_Real Umax;
@@ -246,7 +248,7 @@ void Tesselator::TesselateWithUVCoords(bool compute_edges, float mesh_quality)
   gp_Pnt2d d_coord;
   
   //Triangulate
-  BRepMesh_IncrementalMesh(myShape, myDeviation*mesh_quality, false, 0.5*mesh_quality, false);
+  BRepMesh_IncrementalMesh(myShape, myDeviation*mesh_quality, false, 0.5*mesh_quality, parallel);
 
   for (ExpFace.Init(myShape, TopAbs_FACE); ExpFace.More(); ExpFace.Next()) {
     const TopoDS_Face&    myFace    = TopoDS::Face(ExpFace.Current());
@@ -445,20 +447,72 @@ void Tesselator::ComputeEdges()
 std::string formatFloatNumber(float f) 
 {
   // returns string representation of the float number f.
-  // set precision to 4 digits
   // set epsilon to 1e-3
   float epsilon = 1e-3;
   std::stringstream formatted_float;
   if (std::abs(f) < epsilon) {
     f = 0.;
   }
-  formatted_float << std::setprecision(4) << f;
-  // 4 is perfect for the default quality
-  // for lower quality, it can be down to 3 or 2
-  // for better quality, up to 5 or 6
+  formatted_float << f;
   return formatted_float.str();
 }
 
+std::vector<float> Tesselator::GetVerticesPositionAsTuple()
+{
+  // create the vector and allocate memory
+  std::vector<float> vertices_position;
+  vertices_position.reserve(tot_triangle_count);
+  // loop over tertices
+  int pID = 0;
+  int qID = 0;
+  int rID = 0;
+  for (int i=0;i<tot_triangle_count;i++) {
+      pID = loc_tri_indexes[(i * 3) + 0] * 3;
+      vertices_position.push_back(locVertexcoord[pID]);
+      vertices_position.push_back(locVertexcoord[pID+1]);
+      vertices_position.push_back(locVertexcoord[pID+2]);
+      // Second vertex
+      qID = loc_tri_indexes[(i * 3) + 1] * 3;
+      vertices_position.push_back(locVertexcoord[qID]);
+      vertices_position.push_back(locVertexcoord[qID+1]);
+      vertices_position.push_back(locVertexcoord[qID+2]);
+      // Third vertex
+      rID = loc_tri_indexes[(i * 3) + 2] * 3;
+      vertices_position.push_back(locVertexcoord[rID]);
+      vertices_position.push_back(locVertexcoord[rID+1]);
+      vertices_position.push_back(locVertexcoord[rID+2]);
+    }
+  return vertices_position;
+}
+
+std::vector<float> Tesselator::GetNormalsAsTuple()
+{
+  // create the vector and allocate memory
+  std::vector<float> normals;
+  normals.reserve(tot_triangle_count);
+  // loop over normals
+  int pID = 0;
+  int qID = 0;
+  int rID = 0;
+  for (int i=0;i<tot_triangle_count;i++) {
+      pID = loc_tri_indexes[(i * 3) + 0] * 3;
+      normals.push_back(locNormalcoord[pID]);
+      normals.push_back(locNormalcoord[pID+1]);
+      normals.push_back(locNormalcoord[pID+2]);
+      // Second normal
+      qID = loc_tri_indexes[(i * 3) + 1] * 3;
+      normals.push_back(locNormalcoord[qID]);
+      normals.push_back(locNormalcoord[qID+1]);
+      normals.push_back(locNormalcoord[qID+2]);
+      // Third normal
+      rID = loc_tri_indexes[(i * 3) + 2] * 3;
+      normals.push_back(locNormalcoord[rID]);
+      normals.push_back(locNormalcoord[rID+1]);
+      normals.push_back(locNormalcoord[rID+2]);
+    }
+  return normals;
+}
+
 std::string Tesselator::ExportShapeToX3DIndexedFaceSet()
 {
   std::stringstream str_ifs, str_vertices, str_normals;
@@ -472,28 +526,28 @@ std::string Tesselator::ExportShapeToX3DIndexedFaceSet()
       // First Vertex
       str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[0]]) << " ";
       str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[0]+1]) <<" ";
-      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[0]+2]) <<"\n";
+      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[0]+2]) <<" ";
       // Second vertex
       str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[1]]) << " ";
       str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[1]+1]) << " ";
-      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[1]+2]) << "\n";
+      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[1]+2]) << " ";
       // Third vertex
       str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[2]]) << " ";
       str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[2]+1]) << " ";
-      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[2]+2]) << "\n";
+      str_vertices << formatFloatNumber(locVertexcoord[vertices_idx[2]+2]) << " ";
       // NORMALS
       // First normal
       str_normals << formatFloatNumber(locNormalcoord[normals_idx[0]]) << " ";
       str_normals << formatFloatNumber(locNormalcoord[normals_idx[0]+1]) << " ";
-      str_normals << formatFloatNumber(locNormalcoord[normals_idx[0]+2]) << "\n";
+      str_normals << formatFloatNumber(locNormalcoord[normals_idx[0]+2]) << " ";
       // Second normal
       str_normals << formatFloatNumber(locNormalcoord[normals_idx[1]]) << " ";
       str_normals << formatFloatNumber(locNormalcoord[normals_idx[1]+1]) << " ";
-      str_normals << formatFloatNumber(locNormalcoord[normals_idx[1]+2]) << "\n";
+      str_normals << formatFloatNumber(locNormalcoord[normals_idx[1]+2]) << " ";
       // Third normal
       str_normals << formatFloatNumber(locNormalcoord[normals_idx[2]]) << " ";
       str_normals << formatFloatNumber(locNormalcoord[normals_idx[2]+1]) << " ";
-      str_normals << formatFloatNumber(locNormalcoord[normals_idx[2]+2]) << "\n";
+      str_normals << formatFloatNumber(locNormalcoord[normals_idx[2]+2]) << " ";
   }
   str_ifs << "<TriangleSet solid='false'>\n";
   // write points coordinates
@@ -525,11 +579,11 @@ void Tesselator::ExportShapeToX3D(char * filename, int diffR, int diffG, int dif
     X3Dfile << "<Head>";
     X3Dfile << "<meta name='generator' content='pythonOCC, http://www.pythonocc.org'/>";
     X3Dfile << "</Head>";
-    X3Dfile << "<Scene><Shape><Appearance><Material DEF='Shape_Mat' diffuseColor='0.65 0.65 0.65' ";
-    X3Dfile << "shininess='0.9' specularColor='1 1 1'></Material></Appearance>";
+    X3Dfile << "<Scene><Transform scale='1 1 1'><Shape><Appearance><Material DEF='Shape_Mat' diffuseColor='0.65 0.65 0.7' ";
+    X3Dfile << "specularColor='0.2 0.2 0.2'></Material></Appearance>";
     // write tesselation
     X3Dfile << ExportShapeToX3DIndexedFaceSet();
-    X3Dfile << "</Shape></Scene></X3D>\n";
+    X3Dfile << "</Shape></Transform></Scene></X3D>\n";
     X3Dfile.close();
 
 }
diff --git a/src/Visualization/Tesselator.h b/src/Visualization/Tesselator.h
index bc12338..e008fd6 100644
--- a/src/Visualization/Tesselator.h
+++ b/src/Visualization/Tesselator.h
@@ -96,9 +96,9 @@ class Tesselator
                Standard_Real aRotationAngle);
       Tesselator(TopoDS_Shape aShape);
       ~Tesselator();
-      void Compute(bool uv_coords=true, bool compute_edges=false, float mesh_quality=1.0);
-      void Tesselate(bool compute_edges, float mesh_quality);
-      void TesselateWithUVCoords(bool compute_edges, float mesh_quality);
+      void Compute(bool uv_coords=true, bool compute_edges=false, float mesh_quality=1.0, bool parallel=false);
+      void Tesselate(bool compute_edges, float mesh_quality, bool parallel);
+      void TesselateWithUVCoords(bool compute_edges, float mesh_quality, bool parallel);
       void JoinPrimitives();
       void JoinPrimitivesWithUVCoords();
       void SetDeviation(Standard_Real aDeviation);
@@ -119,5 +119,7 @@ class Tesselator
       int ObjGetEdgeCount();
       int ObjEdgeGetVertexCount(int iEdge);
       void ObjGetTriangle(int trianglenum, int *vertices, int *texcoords, int *normals);
+      std::vector<float> GetVerticesPositionAsTuple();
+      std::vector<float> GetNormalsAsTuple();
 };
 #endif
diff --git a/src/Visualization/Visualization.h b/src/Visualization/Visualization.h
index bc2576e..570a03e 100644
--- a/src/Visualization/Visualization.h
+++ b/src/Visualization/Visualization.h
@@ -20,21 +20,32 @@
 #if !defined __OCC3d_Renderer__
 #define __OCC3d_Renderer__
 
+#ifdef WNT
+  #include <windows.h>
+  #include <WNT_WClass.hxx>
+  #include <WNT_Window.hxx>
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+  #include <Cocoa_Window.hxx>
+#endif
+
 #include <AIS_InteractiveContext.hxx>
 #include <BRepPrimAPI_MakeBox.hxx>
 #include <V3d_Viewer.hxx>
 #include <V3d_View.hxx>
 #include <AIS_Shape.hxx>
 #include <Handle_Graphic3d_GraphicDriver.hxx>
+#include <Graphic3d_Camera.hxx>
+#include <Graphic3d_RenderingParams.hxx>
+#include <Graphic3d_RenderingMode.hxx>
+#include <Graphic3d_Mat4.hxx>
+#include <Graphic3d_Vec4.hxx>
 #include <OpenGl_GraphicDriver.hxx>
 #include <Aspect_DisplayConnection.hxx>
 
 #include <cstdlib>
   
 #ifdef WNT
-  #include <WNT_Window.hxx>
 #elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
-  #include <Cocoa_Window.hxx>
 #else
   #include <Xw_Window.hxx>
 #endif
@@ -45,15 +56,38 @@ public:
 	Standard_EXPORT Display3d();
 	Standard_EXPORT virtual ~Display3d();
 	Standard_EXPORT void Init(long window_handle);
-	Standard_EXPORT Handle_V3d_View& GetView() {return myV3dView;};
+  Standard_EXPORT void SetAnaglyphMode(int mode);
+  Standard_EXPORT void ChangeRenderingParams(int Method,
+                                             Standard_Integer        RaytracingDepth,
+                                             Standard_Boolean        IsShadowEnabled,
+                                             Standard_Boolean        IsReflectionEnabled,
+                                             Standard_Boolean        IsAntialiasingEnabled,
+                                             Standard_Boolean        IsTransparentShadowEnabled,
+                                             int    StereoMode,
+                                             int AnaglyphFilter,
+                                             Standard_Boolean        ToReverseStereo);
+  Standard_EXPORT void EnableVBO();
+  Standard_EXPORT void DisableVBO();
+  Standard_EXPORT Handle_V3d_View& GetView() {return myV3dView;};
 	Standard_EXPORT Handle_V3d_Viewer& GetViewer() {return myV3dViewer;};
 	Standard_EXPORT Handle_AIS_InteractiveContext GetContext() {return myAISContext;};
 	Standard_EXPORT void Test();
-    
+
+  Standard_EXPORT bool IsOffscreen();
+  Standard_EXPORT bool InitOffscreen(int size_x, int size_y);
+  Standard_EXPORT bool SetSize(int size_x, int size_y);
+  Standard_EXPORT bool GetSize(int &size_x, int &size_y);
+  Standard_EXPORT bool GetImageData(const char* &data, size_t &size, const Graphic3d_BufferType& theBufferType = Graphic3d_BT_RGB);
+
 protected:
    Handle_AIS_InteractiveContext myAISContext;
    Handle_V3d_Viewer myV3dViewer;
    Handle_V3d_View myV3dView;
+
+   int mySizeX;
+   int mySizeY;
+   bool myIsOffscreen;
+
    #ifdef WNT
      Handle_WNT_Window myWindow;
    #elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
diff --git a/src/Visualization/Visualization.i b/src/Visualization/Visualization.i
index d21a2d1..a97c983 100644
--- a/src/Visualization/Visualization.i
+++ b/src/Visualization/Visualization.i
@@ -26,8 +26,11 @@
 
 %include ../SWIG_files/common/ExceptionCatcher.i
 %include "python/std_string.i"
+%include "std_vector.i"
 %include "typemaps.i"
 
+%template(vector_float) std::vector<float>;
+
 %typemap(out) float [ANY] {
   int i;
   $result = PyList_New($1_dim0);
@@ -38,16 +41,17 @@
 }
 
 enum theTextureMappingRule {
-	atCube,
-	atNormal,
-	atNormalAutoScale
-	};
+  atCube,
+  atNormal,
+  atNormalAutoScale
+  };
 
 %apply int& OUTPUT {int& v1, int& v2, int& v3}
 %apply float& OUTPUT {float& x, float& y, float& z}
 
 class Tesselator {
  public:
+    %feature("autodoc", "1");
     Tesselator(TopoDS_Shape aShape,
                theTextureMappingRule aTxtMapType,
                float anAutoScaleSizeOnU,
@@ -60,40 +64,92 @@ class Tesselator {
                float aScaleU,
                float aScaleV,
                float aRotationAngle);
+    %feature("autodoc", "1");
     Tesselator(TopoDS_Shape aShape);
+    %feature("autodoc", "1");
+    ~Tesselator();
     %feature("kwargs") Compute;
-    void Compute(bool uv_coords=true, bool compute_edges=false, float mesh_quality=1.0);
+    void Compute(bool uv_coords=true, bool compute_edges=false, float mesh_quality=1.0, bool parallel=false);
     void GetVertex(int ivert, float& x, float& y, float& z);
     void GetNormal(int inorm, float& x, float& y, float& z);
     void GetTriangleIndex(int triangleIdx, int& v1, int& v2, int& v3);
     void GetEdgeVertex(int iEdge, int ivert, float& x, float& y, float& z);
-	float* VerticesList();
-	int ObjGetTriangleCount();
-	int ObjGetVertexCount();
-	int ObjGetNormalCount();
-	int ObjGetEdgeCount();
-	int ObjEdgeGetVertexCount(int iEdge);
+    float* VerticesList();
+    int ObjGetTriangleCount();
+    int ObjGetVertexCount();
+    int ObjGetNormalCount();
+    int ObjGetEdgeCount();
+    int ObjEdgeGetVertexCount(int iEdge);
     std::string ExportShapeToX3DIndexedFaceSet();
-	std::string ExportShapeToThreejsJSONString(char *shape_function_name, bool export_uv=false);
-	%feature("kwargs") ExportShapeToX3D;
-	void ExportShapeToX3D(char *filename, int diffR=1, int diffG=0, int diffB=0);
+    std::string ExportShapeToThreejsJSONString(char *shape_function_name, bool export_uv=false);
+    %feature("kwargs") ExportShapeToX3D;
+    void ExportShapeToX3D(char *filename, int diffR=1, int diffG=0, int diffB=0);
+    std::vector<float> GetVerticesPositionAsTuple();
+    std::vector<float> GetNormalsAsTuple();
 };
 
 class Display3d {
  public:
-	%feature("autodoc", "1");
-	Display3d();
-	%feature("autodoc", "1");
-	~Display3d();
-	%feature("autodoc", "1");
-	void Init(const long handle);
-	%feature("autodoc", "1");
-	Handle_V3d_View& GetView();
-	%feature("autodoc", "1");
-	Handle_V3d_Viewer& GetViewer();
-	%feature("autodoc", "1");
-	Handle_AIS_InteractiveContext GetContext();
-	%feature("autodoc", "1");
-	void Test();
+    %feature("autodoc", "1");
+    Display3d();
+    %feature("autodoc", "1");
+    ~Display3d();
+    %feature("autodoc", "1");
+    void Init(const long handle);
+    %feature("autodoc", "1");
+    void SetAnaglyphMode(int mode);
+    %feature("autodoc", "1");
+    void ChangeRenderingParams(int  Method,
+                               int  RaytracingDepth,
+                               bool IsShadowEnabled,
+                               bool IsReflectionEnabled,
+                               bool IsAntialiasingEnabled,
+                               bool IsTransparentShadowEnabled,
+                               int  StereoMode,
+                               int  AnaglyphFilter,
+                               bool ToReverseStere);
+    %feature("autodoc", "1");
+    void EnableVBO();
+    %feature("autodoc", "1");
+    void DisableVBO();
+    %feature("autodoc", "1");
+    Handle_V3d_View& GetView();
+    %feature("autodoc", "1");
+    Handle_V3d_Viewer& GetViewer();
+    %feature("autodoc", "1");
+    Handle_AIS_InteractiveContext GetContext();
+    %feature("autodoc", "1");
+    void Test();
+
+    %feature("autodoc", "1");
+    bool InitOffscreen(int size_x, int size_y);
+    %feature("autodoc", "1");
+    bool SetSize(int size_x, int size_y);
+    %feature("autodoc", "1");
+    bool IsOffscreen();
+};
+
+%extend Display3d {
+    PyObject* GetImageData(int bufType = 0) {
+        const char * data;
+        size_t size = 0;
+        Graphic3d_BufferType theBufferType = (Graphic3d_BufferType)bufType;
+
+        if ($self->GetImageData(data, size, theBufferType)) {
+            return PyBytes_FromStringAndSize(data, (Py_ssize_t)size);
+        }
+        Py_RETURN_NONE;
+    }
+
+    PyObject* GetSize() {
+        int size_x;
+        int size_y;
+
+        if ($self->GetSize(size_x, size_y)) {
+            return Py_BuildValue("ii", size_x, size_y);
+        }
+        Py_RETURN_NONE;
+    }
+
 };
 
